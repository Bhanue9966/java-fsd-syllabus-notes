# ðŸš€ 10. DevOps and Cloud

## 07-docker-compose-volumes.md

### 1\. What is Docker Compose?

**Docker Compose** is a tool used for defining and running multi-container Docker applications. Instead of managing individual containers with complex `docker run` commands, you define your entire application stack (services, networks, and volumes) in a single YAML file, typically named **`docker-compose.yml`**.

  * **Goal:** Simplify the entire application lifecycle, from development to production staging, allowing you to start or stop the entire stack with a single command.

### 2\. The `docker-compose.yml` File Structure

The Compose file is organized into three main sections: `version`, `services`, and `volumes`.

| Section | Purpose |
| :--- | :--- |
| **`version`** | Specifies the version of the Docker Compose file format (currently `3.x` is standard). |
| **`services`** | Defines all the individual application components (the containers) that make up your stack. |
| **`volumes`** | Declares the named volumes required for persistent data storage. |

### 3\. Code Example: Spring Boot and PostgreSQL Stack

This file defines two services: `app` (your Spring Boot container) and `postgres_db` (your PostgreSQL container).

**`docker-compose.yml`**

```yaml
version: "3.8"

services:
  # 1. Spring Boot Application Service
  app:
    build: . # Tells Compose to look for a Dockerfile in the current directory and build the image
    container_name: spring-job-app
    ports:
      - "8080:8080" # Map host port to container port
    environment:
      # CRITICAL: Spring must connect to the database using the SERVICE NAME (postgres_db), 
      # not localhost, because they are on the same internal Docker network.
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres_db:5432/job_app_db
      - SPRING_DATASOURCE_USERNAME=appuser
      - SPRING_DATASOURCE_PASSWORD=mysecretpassword
    
    depends_on:
      - postgres_db # Ensures the DB container starts before the application container

  # 2. PostgreSQL Database Service
  postgres_db:
    image: 'postgres:14-alpine' # Use a lightweight official image
    container_name: postgres-server
    restart: always # Always restart if it fails

    # Environment variables match the app configuration and define the database setup
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: mysecretpassword
      POSTGRES_DB: job_app_db

    # Persistence: Map the named volume to the internal data directory
    volumes:
      - postgres_data:/var/lib/postgresql/data # Mount the named volume defined below

# 3. Named Volumes Declaration
volumes:
  postgres_data:
    # Docker manages this volume, ensuring data persists even if containers are removed.
```

### 4\. Automatic Networking

A key advantage of Docker Compose is that it automatically creates a dedicated, private network for all defined services.

  * **Service Name Resolution:** Within this network, containers can communicate with each other using the service names defined in the YAML file (e.g., `postgres_db` and `app`).
  * **Connection String:** Notice that the Spring Boot application connects to the database using the hostname **`postgres_db`** in the `SPRING_DATASOURCE_URL`, not `localhost`.

### 5\. Docker Compose Commands

Managing the entire stack is reduced to two simple commands executed from the directory containing the `docker-compose.yml` file:

| Command | Purpose | Explanation |
| :--- | :--- | :--- |
| `docker compose up -d` | **Build, Create, and Start** | Builds images (if needed), creates containers, and starts them in **detached** (background) mode. |
| `docker compose down` | **Stop and Remove** | Gracefully stops the running containers and removes the containers and the default network. **Crucially, it does NOT remove the persistent volumes.** |
| `docker compose logs` | **View Logs** | Shows the combined log output of all services in the stack. |

By using Docker Compose, you ensure a consistent and portable development environment, which is the foundation for moving to cloud deployment.
