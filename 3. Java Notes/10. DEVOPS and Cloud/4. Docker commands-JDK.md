# ðŸš€ 10. DevOps and Cloud

## 04-docker-commands-jdk.md

### 1\. Essential Docker Client Commands

The Docker **Client** interacts with the **Daemon** to manage the lifecycle of images and containers. Here are the most fundamental commands:

#### A. Image Management

| Command | Purpose | Example |
| :--- | :--- | :--- |
| `docker pull` | Downloads an image from a Registry (defaulting to Docker Hub). | `docker pull openjdk:17-jdk-slim` |
| `docker images` | Lists all images stored locally on the Docker Host. | `docker images` |
| `docker rmi` | Removes a local image. | `docker rmi <IMAGE_ID>` |

#### B. Container Management

| Command | Purpose | Example |
| :--- | :--- | :--- |
| `docker ps` | Lists **running** containers. | `docker ps` |
| `docker ps -a` | Lists **all** containers (running and stopped). | `docker ps -a` |
| `docker stop` | Gracefully stops a running container. | `docker stop <CONTAINER_ID>` |
| `docker rm` | Removes a stopped container. | `docker rm <CONTAINER_ID>` |
| `docker logs` | Fetches the logs of a container. | `docker logs <CONTAINER_ID>` |

-----

### 2\. The Core Command: `docker run`

The `docker run` command is the most frequently used. It performs two actions:

1.  **Creates** a container from a specified image.
2.  **Starts** the container.

#### A. Running a Simple Command (One-off)

We can use `docker run` to instantly execute a command inside a new container. Here, we run the `java -version` command using the official OpenJDK image.

**Command:**

```bash
docker run openjdk:17-jdk-slim java -version
```

**Expected Output:**

```
openjdk version "17.0.9" 2023-10-17
OpenJDK Runtime Environment Temurin-17.0.9+9 (build 17.0.9+9)
...
```

  * **Explanation:** Docker checks locally for `openjdk:17-jdk-slim`. If it's missing, it pulls it from Docker Hub, starts a container, executes `java -version`, prints the output, and then the container **stops and exits** because the command finished.

#### B. Running a Container and Keeping it Alive

To run server-like applications (like a Spring Boot app), the container's main process must stay alive. You typically need the following flags:

| Flag | Full Name | Purpose |
| :--- | :--- | :--- |
| `-d` | `--detach` | Runs the container in the **background** (detached mode). |
| `-p` | `--publish` | **Maps a port** from the Host machine to a port inside the Container (`HostPort:ContainerPort`). |
| `--name` | | Assigns a human-readable **name** to the container (e.g., `my-java-app`). |
| `-it` | | **Interactive TTY:** Used for interactive shells (e.g., `bash`). |

**Example: Running an Interactive Shell**

This command starts a container and drops you into a bash shell, allowing you to manually explore the container's environment.

```bash
docker run -it --rm --name bash-test openjdk:17-jdk-slim /bin/bash
```

  * **`--rm`:** Removes the container automatically when you exit the shell, preventing clutter.
  * **`/bin/bash`:** The command to execute is the bash shell.

-----

### 3\. Running a Custom Java Application

To run your own Java `.jar` file, you need to use the Docker volume mapping feature to inject the file into the container's file system:

**Scenario:** You have a file named `my-app.jar` in your current directory.

**Command:**

```bash
docker run -d -p 8080:8080 --name my-server-app -v $(pwd)/my-app.jar:/app/app.jar openjdk:17-jdk-slim java -jar /app/app.jar
```

  * **`-v $(pwd)/my-app.jar:/app/app.jar`**: This is a **volume mount**. It mounts the local file (`my-app.jar` in the current directory) to a path inside the container (`/app/app.jar`).
  * **`java -jar /app/app.jar`**: This is the command that the container executes, running your application.
  * **`-p 8080:8080`**: Maps the host's port 8080 to the container's port 8080, making your application accessible from your machine.

This method, while functional, is generally replaced by creating a **Dockerfile** for better repeatability and caching, which is covered in the next modules.

