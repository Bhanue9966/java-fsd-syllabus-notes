# ðŸš€ 10. DevOps and Cloud

## 05-docker-spring-boot.md

### 1\. The Need for a Dockerfile

While you can run a pre-compiled Spring Boot JAR using a volume mount and `docker run` (as seen in `04-docker-commands-jdk.md`), this approach is inefficient and not repeatable.

The **Dockerfile** is a text file that contains all the commands a user could call on the command line to assemble an **Image**. It automates the entire process, from setting up the base environment to adding application code.

### 2\. Spring Boot Dockerfile Structure

A standard Dockerfile for a Spring Boot application involves a few critical instructions:

| Instruction | Purpose | Example |
| :--- | :--- | :--- |
| **`FROM`** | Specifies the **base image** (the starting point, e.g., an OS with a JDK). | `FROM openjdk:17-jdk-slim` |
| **`ARG`** | Defines a build-time variable that is not visible in the final image. | `ARG JAR_FILE` |
| **`COPY`** | Copies files from the local filesystem (host) into the image. | `COPY target/app.jar /app.jar` |
| **`ENTRYPOINT`** | Defines the main command that will be executed when the container starts. | `ENTRYPOINT ["java", "-jar", "/app.jar"]` |

### 3\. Code Example: Basic Dockerfile

This example assumes you have already packaged your Spring Boot application into a single executable JAR file located at `target/myapp.jar` using Maven or Gradle.

**`Dockerfile`**

```dockerfile
# 1. Base Image: Start with a light-weight Linux distribution 
# that includes the Java 17 runtime (JDK slim is smaller than the full JDK).
FROM openjdk:17-jdk-slim

# 2. Argument: Define the name of the JAR file we are expecting from the host machine.
ARG JAR_FILE=target/my-spring-app.jar

# 3. Copy: Copy the application JAR file from the host's filesystem 
# into the root of the container's file system, renaming it to 'app.jar'.
COPY ${JAR_FILE} /app.jar

# 4. Port: Inform Docker that the container listens on this port 
# (Spring Boot's default port). This is metadata only; mapping still requires -p.
EXPOSE 8080

# 5. Entrypoint: Define the command to run the application when the container starts.
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### 4\. Building the Docker Image

The `docker build` command reads the instructions in the Dockerfile and executes them layer by layer to create a final, portable image.

#### A. Build Command Syntax

We use the `-t` (tag) flag to name the image and the `.` to indicate the Dockerfile is in the current directory.

```bash
# Syntax: docker build -t <image-name>:<tag> <path-to-dockerfile>
docker build -t my-spring-app:1.0 .
```

#### B. Build with Argument

If your JAR file is named differently, you pass the `JAR_FILE` argument during the build:

```bash
docker build -t my-spring-app:1.0 \
    --build-arg JAR_FILE=target/my-custom-name.jar .
```

### 5\. Running the Container

Once the image is built locally, running it is straightforward.

```bash
# Syntax: docker run -d -p HostPort:ContainerPort --name <container-name> <image-name>:<tag>
docker run -d \
    -p 8080:8080 \
    --name spring-server \
    my-spring-app:1.0
```

  * **Explanation:** Docker starts the container, executes the `ENTRYPOINT` command (`java -jar /app.jar`), and maps the host's port 8080 to the container's port 8080, making the Spring application accessible via `http://localhost:8080`.

### 6\. Advanced Concept: Multi-Stage Builds (Optimization)

The JAR file is built using the **JDK** (Java Development Kit), but only the **JRE** (Java Runtime Environment) is needed to run the application.

A Multi-Stage Build uses two or more `FROM` statements in a single Dockerfile to:

1.  **Build Stage:** Use a heavy base image (e.g., Maven or full JDK) to compile the code.
2.  **Runtime Stage:** Copy only the final artifact (the JAR) into a minimal, production-ready image (e.g., JRE or bare minimum OS) to drastically reduce the final image size.

This optimization is crucial for production environments.
