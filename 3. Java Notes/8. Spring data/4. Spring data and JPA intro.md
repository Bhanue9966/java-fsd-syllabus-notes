# ðŸ’¾ 8. Spring Data

## 04-spring-data-jpa-intro.md

### ðŸ“š Introduction to Spring Data JPA

**Spring Data JPA** is not a persistence framework itself (like Hibernate or EclipseLink). Instead, it is an **abstraction layer** that sits on top of the **Java Persistence API (JPA)**, simplifying the implementation of data access layers (repositories).

It drastically reduces boilerplate code by allowing developers to define repository methods simply by declaring an interface and specifying method signatures based on naming conventions.

#### Core Concepts

1.  **JPA (Java Persistence API):** The **specification** (standard interface) for persisting Java objects to a relational database. It defines annotations like `@Entity`, `@Id`, and the `EntityManager` interface.
2.  **Hibernate:** The most popular **implementation** of the JPA specification. Spring Data JPA uses Hibernate as its default provider.
3.  **Spring Data JPA:** The **abstraction** that generates repository implementation code at runtime based on method names defined in interfaces.

-----

### 1\. Key Dependencies and Configuration

To use Spring Data JPA, you need three main components: the Spring Data JPA starter, a JPA provider (Hibernate is included), and a database driver (e.g., PostgreSQL or H2).

#### Maven (`pom.xml`)

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
</dependencies>
```

#### Configuration (`application.properties`)

In addition to the basic `DataSource` configuration (as seen in `03-spring-jdbc-postgres.md`), we add specific JPA/Hibernate settings.

```properties
# --- JPA/Hibernate Configuration ---

# 1. Show SQL: Logs all executed SQL queries (useful for debugging)
spring.jpa.show-sql=true

# 2. SQL Formatting: Makes the logged SQL readable
spring.jpa.properties.hibernate.format_sql=true

# 3. DDL Auto: Controls how Hibernate manages the database schema
#   - none: (Recommended for production) Do nothing.
#   - update: Updates the schema incrementally.
#   - create: Drops existing tables and creates new ones (Dangerous!).
#   - create-drop: Creates on startup, drops on shutdown (Good for testing).
spring.jpa.hibernate.ddl-auto=update 
```

-----

### 2\. Defining the Entity (`@Entity`)

The model class must be annotated with JPA annotations to map it to a database table.

**`src/main/java/com/example/model/Product.java`**

```java
package com.example.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

@Entity // 1. Marks this class as a JPA entity, mapped to a table named 'product'
public class Product {
    
    // 2. Marks the primary key field
    @Id
    // 3. Specifies how the ID is generated (IDENTITY uses DB auto-increment feature)
    @GeneratedValue(strategy = GenerationType.IDENTITY) 
    private Long id;
    
    private String name;
    private double price;
    
    // Default constructor is required by JPA specification
    public Product() {}
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    // Getters and Setters (essential for JPA persistence)
    // ... (omitted for brevity)
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public double getPrice() { return price; }
    public void setPrice(double price) { this.price = price; }
}
```

-----

### 3\. Creating the Repository Interface (The Magic)

This is where Spring Data JPA eliminates most of the boilerplate code that was required with `JdbcTemplate`. You only need to define an interface that extends one of Spring Data's base interfaces.

**`src/main/java/com/example/repository/ProductRepository.java`**

```java
package com.example.repository;

import com.example.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository // Standard stereotype annotation
// JpaRepository<Entity Class, Primary Key Type>
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // All basic CRUD operations are automatically implemented by Spring Data JPA
    // (e.g., save(), findById(), findAll(), delete())
    
    // --- Custom Query Methods (Derived Queries) ---
    
    // Spring Data automatically generates the implementation for this method
    // based on the keywords in the name (findBy + PropertyName)
    Product findByName(String name); 
    
    // Spring Data handles the 'greater than' logic
    List<Product> findByPriceGreaterThan(double price);
}
```

#### Explanation of `JpaRepository`

By extending `JpaRepository<Product, Long>`, the `ProductRepository` interface automatically inherits around **18 methods** for common data access tasks, including:

  * **`save(T entity)`:** Performs INSERT or UPDATE.
  * **`findById(ID id)`:** Fetches a single entity by ID.
  * **`findAll()`:** Fetches all entities.
  * **`delete(T entity)`:** Deletes an entity.

The actual implementation class for this interface is **generated at runtime** by Spring Data JPA.

