# üíæ 8. Spring Data

## 01-spring-jdbc-intro.md

### üîó Introduction to Spring JDBC

The **Java Database Connectivity (JDBC)** API is the standard low-level interface for connecting to and interacting with a relational database in Java. However, native JDBC requires extensive **boilerplate code** for connection management, exception handling, and resource cleanup.

Spring JDBC provides an abstraction layer over the native JDBC API, significantly reducing boilerplate and making database access cleaner and less error-prone.

#### 1\. The Problem with Native JDBC

Consider the steps required for a simple query in standard JDBC:

1.  Load the driver class.
2.  Establish a **`Connection`**.
3.  Create a **`Statement`** or **`PreparedStatement`**.
4.  Execute the SQL query.
5.  Process the **`ResultSet`**.
6.  Handle vendor-specific **`SQLException`** (a checked exception).
7.  Manually close the `ResultSet`, `Statement`, and `Connection` in a `finally` block (or using try-with-resources).

This process is repetitive and error-prone, particularly the resource cleanup.

#### 2\. The Solution: Spring JDBC Abstraction

Spring JDBC solves this by handling the resource management and exception translation automatically.

  * **Resource Management:** Spring handles opening and closing connections, statements, and result sets, eliminating the need for boilerplate `finally` blocks.
  * **Exception Translation:** Spring converts the low-level, vendor-specific **`SQLException`** (a checked exception) into Spring's unified hierarchy of runtime (unchecked) **`DataAccessException`**. This is a major benefit, as you only need to catch specific, meaningful runtime exceptions.

### 3\. Key Component: `JdbcTemplate`

The heart of Spring JDBC is the **`JdbcTemplate`** class. It is the central class that manages all the interaction with the database.

  * **Purpose:** Executes SQL queries, updates, and stored procedure calls, delegates the job of connection management, and translates exceptions.
  * **Need for a DataSource:** `JdbcTemplate` requires a **`DataSource`** bean to obtain database connections.

#### Configuration (Using Spring Boot)

In a modern Spring Boot application, minimal configuration is needed.

#### üìù Step 1: Add Dependencies

We need the necessary starters in `pom.xml` (or build.gradle):

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

#### üìù Step 2: Configure the Database in `application.properties`

Spring Boot automatically creates and configures a `DataSource` bean based on these properties.

**`src/main/resources/application.properties`**

```properties
# H2 In-Memory Database Configuration
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.h2.console.enabled=true # Optional: for viewing the database
```

#### üìù Step 3: Auto-Configure `JdbcTemplate`

Once the `DataSource` bean is configured, Spring Boot automatically creates and registers a **`JdbcTemplate`** bean that uses that `DataSource`. This bean can then be simply **autowired** into any repository class.

This sets the stage for the next topic, where we will actually use the `JdbcTemplate` to perform CRUD operations.

