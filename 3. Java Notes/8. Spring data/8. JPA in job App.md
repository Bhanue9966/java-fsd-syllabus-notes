# üíæ 8. Spring Data

## 08-jpa-in-job-app.md

### üè¢ Integrating JPA in a Multi-Layered Application

In a professional Spring Boot application (often referred to as a "Job Application" or a complex project), Spring Data JPA is never used in isolation. It is systematically integrated into a multi-layered architecture to separate concerns, improve testability, and enforce business rules.

This standard architecture involves at least three layers: **Controller**, **Service**, and **Repository**.

-----

### 1\. The Data Layer: Entity and Repository

This layer handles direct interaction with the database.

#### A. The Entity (`@Entity`)

The Entity represents the database table.

```java
// src/main/java/com/app/entity/JobPosting.java
@Entity
@Table(name = "job_postings")
public class JobPosting {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
    private String description;
    private String company;
    // Getters and Setters...
}
```

#### B. The Repository

The Repository provides the basic CRUD methods and custom data access methods (derived queries, JPQL).

```java
// src/main/java/com/app/repository/JobPostingRepository.java
public interface JobPostingRepository extends JpaRepository<JobPosting, Long> {
    // Custom search example using Query Derivation
    List<JobPosting> findByTitleContainingIgnoreCase(String keyword);
}
```

-----

### 2\. The Business Layer: Service

The **Service Layer** is the core of the application. It contains the business logic, handles transaction management, and coordinates interactions between the Repository and other services.

  * **Key:** It always interacts with the Repository, but **never** directly with the Controller or the database connection.
  * **Transactional:** Write operations (`save`, `update`, `delete`) must be annotated with **`@Transactional`** to ensure data integrity.

#### Code Example: Service Layer

```java
// src/main/java/com/app/service/JobPostingService.java
@Service
public class JobPostingService {

    private final JobPostingRepository jobPostingRepository;

    @Autowired // Dependency Injection
    public JobPostingService(JobPostingRepository jobPostingRepository) {
        this.jobPostingRepository = jobPostingRepository;
    }

    // CREATE/UPDATE operation - Requires transaction management
    @Transactional 
    public JobPosting createPosting(JobPosting posting) {
        // Business Rule Example: Cleanse the description before saving
        posting.setDescription(posting.getDescription().trim());
        return jobPostingRepository.save(posting);
    }
    
    // READ operation - Typically read-only transaction (optimization)
    @Transactional(readOnly = true)
    public List<JobPosting> findJobsByKeyword(String keyword) {
        if (keyword.length() < 3) {
            // Business Rule Example: Prevent overly broad searches
            throw new IllegalArgumentException("Keyword must be at least 3 characters.");
        }
        return jobPostingRepository.findByTitleContainingIgnoreCase(keyword);
    }
}
```

-----

### 3\. The Presentation Layer: Controller and DTOs

The **Controller Layer** is responsible for handling HTTP requests and responses. It acts as a bridge between the outside world and the Service layer.

#### Key Concept: Data Transfer Objects (DTOs)

Controllers should communicate with the client using **DTOs**, not the raw JPA `@Entity` objects.

  * **Security:** Prevents sensitive entity fields (like internal IDs or audit fields) from being accidentally exposed.
  * **Decoupling:** Protects the API contract from changes in the database entity structure.
  * **Validation:** DTOs are the best place to use validation annotations (`@Valid`).

#### Code Example: Controller Layer (REST)

```java
// src/main/java/com/app/controller/JobPostingController.java
@RestController
@RequestMapping("/api/jobs")
public class JobPostingController {

    private final JobPostingService jobPostingService;
    // private final PostingMapper mapper; // Used to convert DTO <-> Entity

    // Constructor Injection...

    // 1. CREATE Endpoint
    @PostMapping
    public ResponseEntity<JobPostingDto> addJob(@RequestBody JobPostingDto jobDto) {
        
        // 1. Convert DTO to Entity
        JobPosting jobEntity = convertToEntity(jobDto);
        
        // 2. Delegate business logic to the Service layer
        JobPosting savedJob = jobPostingService.createPosting(jobEntity);
        
        // 3. Convert saved Entity back to DTO for response
        JobPostingDto responseDto = convertToDto(savedJob);
        
        // 4. Return 201 Created
        return new ResponseEntity<>(responseDto, HttpStatus.CREATED);
    }
    
    // 2. SEARCH Endpoint
    @GetMapping("/search")
    public List<JobPostingDto> searchJobs(@RequestParam String keyword) {
        // Delegate to Service, which uses the JPA Repository search
        List<JobPosting> jobEntities = jobPostingService.findJobsByKeyword(keyword);
        
        // Convert the list of Entities to a list of DTOs
        return jobEntities.stream()
                          .map(this::convertToDto)
                          .collect(Collectors.toList());
    }
    
    // Placeholder DTO/Entity Conversion methods (usually handled by Mapper libraries like MapStruct)
    private JobPosting convertToEntity(JobPostingDto dto) { /* ... */ return new JobPosting(); }
    private JobPostingDto convertToDto(JobPosting entity) { /* ... */ return new JobPostingDto(); }
}
```

This multi-layered approach ensures clean separation, making the application robust and maintainable, which is the standard for Spring-based production systems.
