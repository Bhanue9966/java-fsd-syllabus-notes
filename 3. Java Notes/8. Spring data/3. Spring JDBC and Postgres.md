# üíæ 8. Spring Data

## 03-spring-jdbc-postgres.md

### üêò Configuring Spring JDBC with PostgreSQL

When moving from an in-memory database (like H2) to an external, production-ready database (like PostgreSQL), the application needs to be configured with the correct driver and connection details. The core `JdbcTemplate` logic remains blissfully unaware of the underlying database type.

### 1\. Dependency Management

The first step is to include the **PostgreSQL JDBC Driver** (known as the `Postgresql-jdbc` or `PgJDBC` driver) and ensure the `spring-boot-starter-jdbc` is still present.

#### Maven (`pom.xml`)

We replace the H2 dependency with the PostgreSQL dependency, keeping the `jdbc` starter:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>

    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

### 2\. Connection Configuration

The `DataSource` configuration in `application.properties` must be updated to point to the external PostgreSQL instance, including the host, port, database name, and credentials.

#### `src/main/resources/application.properties`

```properties
# --- PostgreSQL Database Configuration ---

# 1. Database Driver Class (No longer required explicitly in Spring Boot, but good to know)
# spring.datasource.driver-class-name=org.postgresql.Driver 

# 2. JDBC URL: Defines the host, port, and database name.
# Default PostgreSQL port is 5432
spring.datasource.url=jdbc:postgresql://localhost:5432/mydatabase

# 3. Credentials
spring.datasource.username=postgres_user
spring.datasource.password=secure_password

# 4. Connection Pooling (HikariCP is the default in Spring Boot)
# spring.datasource.hikari.maximum-pool-size=10
# spring.datasource.hikari.minimum-idle=2

# 5. Database Platform (Optional, for advanced features/SQL dialects)
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# 6. Database Initialization (Crucial for setting up the schema)
# This setting tells Spring Boot to automatically execute schema.sql and data.sql
spring.sql.init.mode=always
```

### 3\. Database Initialization Scripts

Spring Boot automatically runs SQL scripts named `schema.sql` (for DDL) and `data.sql` (for initial data) if they are present in the `src/main/resources` folder and initialization is enabled (`spring.sql.init.mode=always`).

#### `src/main/resources/schema.sql`

Ensure your SQL syntax is compliant with PostgreSQL standards (e.g., using `SERIAL` for auto-incrementing IDs, which differs from H2/MySQL).

```sql
-- PostgreSQL specific syntax
DROP TABLE IF EXISTS employees;

CREATE TABLE employees (
    -- Use SERIAL for auto-incrementing primary keys
    id BIGSERIAL PRIMARY KEY, 
    name VARCHAR(255) NOT NULL,
    salary NUMERIC(10, 2) -- Use NUMERIC/DECIMAL for precision in money
);
```

#### Note on Auto-Generated Keys

When using PostgreSQL's `BIGSERIAL` (auto-incrementing ID), the `JdbcTemplate` needs a slightly different approach for **INSERT** operations to retrieve the generated key.

We use **`KeyHolder`** and **`PreparedStatementCreatorFactory`** with the `update(PreparedStatementCreator, KeyHolder)` method.

```java
// Example method to insert and get the generated ID
public Long save(Employee employee) {
    KeyHolder keyHolder = new GeneratedKeyHolder();
    
    // SQL uses DEFAULT keyword for the auto-generated ID
    final String INSERT_SQL = "INSERT INTO employees (name, salary) VALUES (?, ?) RETURNING id";
    
    jdbcTemplate.update(connection -> {
        PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[]{"id"});
        ps.setString(1, employee.getName());
        ps.setDouble(2, employee.getSalary());
        return ps;
    }, keyHolder);

    // Retrieve the generated key
    return keyHolder.getKey().longValue();
}
```

### 4\. Benefit of Abstraction

The key takeaway is that the core repository logic (the methods that use `findAll()`, `findById()`, and `update()`) created in **`02-jdbc-template-repo.md`** can be reused with little to no change, provided the SQL is standard and the generated key handling is addressed.

Spring JDBC successfully separates the data access logic from the vendor-specific database connection details.

