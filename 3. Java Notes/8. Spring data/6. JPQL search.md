# üíæ 8. Spring Data

## 06-jpql-search.md

### üîç Advanced Searching with Spring Data JPA

While the derived query methods (like `findByName()`) are great for simple searches, complex requirements often need explicit queries. Spring Data JPA provides two main ways to write custom search logic:

1.  **Derived Queries (Advanced):** Leveraging specific keywords in method names for complex filtering.
2.  **JPQL Queries (`@Query`):** Writing SQL-like queries based on entity objects and fields.

### 1\. Advanced Derived Queries

Spring Data JPA supports many keywords in method names to generate sophisticated queries automatically.

| Keyword | Example Method Signature | Generated JPQL Condition |
| :--- | :--- | :--- |
| `And` / `Or` | `findByPriceLessThanAndNameContaining(double p, String n)` | `WHERE p.price < :p AND p.name LIKE %:n%` |
| `GreaterThan` | `findBySalaryGreaterThan(double salary)` | `WHERE e.salary > :salary` |
| `Between` | `findByPriceBetween(double min, double max)` | `WHERE p.price BETWEEN :min AND :max` |
| `IsNull` | `findByNameIsNull()` | `WHERE p.name IS NULL` |
| `Containing` | `findByNameContaining(String partialName)` | `WHERE p.name LIKE %:partialName%` (Case sensitive) |
| `IgnoreCase` | `findByNameIgnoreCase(String name)` | `WHERE UPPER(p.name) = UPPER(:name)` |

#### Code Example: Advanced Derived Queries

In our **`ProductRepository.java`** interface:

```java
// 1. Combining multiple criteria (AND)
// Finds products with price less than the given amount AND name contains the string
List<Product> findByPriceLessThanAndNameContaining(double price, String partialName);

// 2. Using Between for a range search
List<Product> findByPriceBetween(double minPrice, double maxPrice);

// 3. Sorting and Limiting (returns the first 5 results, ordered by price descending)
List<Product> findFirst5ByOrderOrderByPriceDesc();
```

-----

### 2\. Custom Queries with `@Query` (JPQL)

For highly complex queries, joins, or specific aggregate functions that are hard to express via method names, we use the **`@Query`** annotation. This allows us to write **JPQL**.

**JPQL vs. SQL:**

  * **JPQL** operates on **entity objects** and their fields (`SELECT p FROM Product p`).
  * **SQL** operates on **tables** and their columns (`SELECT * FROM product`).

#### A. JPQL Query (Based on Entity Fields)

The query references the Java class name (`Product`) and its fields (`price`, `name`), not the database table and columns.

**`ProductRepository.java`**

```java
// Finds products above a specific price threshold.
// ':price' is a named parameter, mapped to the method argument @Param("price").
@Query("SELECT p FROM Product p WHERE p.price > :price")
List<Product> findExpensiveProducts(@Param("price") double price);

// Finds products by part of the name, case-insensitively.
// The '%' wildcards are part of the JPQL/SQL LIKE pattern.
@Query("SELECT p FROM Product p WHERE UPPER(p.name) LIKE UPPER(CONCAT('%', :nameFragment, '%'))")
List<Product> searchByNameFragment(@Param("nameFragment") String fragment);
```

#### B. Native SQL Query

If you need to use database-specific functions or very complex joins that are difficult in JPQL, you can use Native SQL by setting `nativeQuery = true`.

**`ProductRepository.java`**

```java
// Uses standard SQL (not JPQL) to find the average price.
// Note: This returns a List<Object[]> or List<Double>, not an Entity, 
// so the return type is typically primitive/wrapper or Object.
@Query(value = "SELECT AVG(salary) FROM employee_table", nativeQuery = true)
Double calculateAverageSalaryNative(); 
```

### 3\. Modifying Queries (`@Modifying`)

By default, `@Query` is used for **SELECT** operations. If you want to use a custom JPQL or Native SQL query to perform an **UPDATE** or **DELETE** operation, you must add the **`@Modifying`** annotation.

  * **Crucial:** Modifying queries require wrapping the calling service method in a **transaction** using the `@Transactional` annotation to ensure data integrity.

#### Code Example: Modifying Query

**`ProductRepository.java`**

```java
// Decreases the price of all products by a given percentage.
// Must be used with @Modifying and called within a @Transactional context.
@Modifying
@Query("UPDATE Product p SET p.price = p.price * (1 - :discountPercentage)")
int bulkApplyDiscount(@Param("discountPercentage") double discount); // Returns the count of records updated
```

**`ProductService.java` (Calling the Modifying Query)**

```java
package com.example.service;

import com.example.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class ProductService {
    
    private final ProductRepository productRepository;
    // ... constructor ...

    // This method MUST be transactional because it calls a modifying query
    @Transactional 
    public int applySale(double percentage) {
        System.out.println("Applying " + (percentage * 100) + "% discount globally...");
        return productRepository.bulkApplyDiscount(percentage);
    }
}
```

**Example Trace:**

1.  Service method `applySale` begins a database transaction.
2.  `bulkApplyDiscount` executes the JPQL `UPDATE`.
3.  The service method finishes, and the transaction is committed, making the changes permanent in the database.

