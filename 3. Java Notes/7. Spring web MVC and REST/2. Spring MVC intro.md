# üåê 7. Spring Web MVC and REST

## 02-spring-mvc-intro.md

### üèõÔ∏è The Model-View-Controller (MVC) Pattern

Spring Web MVC is built around the classic **Model-View-Controller (MVC)** design pattern. The MVC pattern is a fundamental architectural pattern that separates an application into three interconnected parts, isolating the business logic from the user interface.

| Component | Role | Spring Implementation |
| :--- | :--- | :--- |
| **Model** | Holds the application's data and business state. It is independent of the View. | Plain Old Java Objects (POJOs), Services, and Repository layers. Data passed to the View. |
| **View** | Responsible for rendering the user interface (UI) based on the data in the Model. | JSP, **Thymeleaf**, FreeMarker templates, or rendering engine. |
| **Controller** | Handles user input, processes requests, updates the Model, and selects the View to render. | Classes annotated with `@Controller` or `@RestController`. |

### 2. The Role of the `DispatcherServlet`

In the Java Servlet world, Spring MVC is implemented as a single, centralized **Front Controller** servlet called the **`DispatcherServlet`**.

* **Front Controller Pattern:** This is a design pattern where a single entry point (the `DispatcherServlet`) handles every incoming request.
* **Delegation:** The `DispatcherServlet` is not responsible for handling the request logic itself; instead, it delegates the work to specialized components (like Controllers and View Resolvers).

In a Spring Boot application, the `DispatcherServlet` is **automatically configured** and registered by the `@SpringBootApplication` annotation, eliminating the need for any manual `web.xml` configuration.

### 3. The Spring MVC Request Flow

The entire life cycle of an incoming request, from client to server and back, is managed by the `DispatcherServlet` and a set of Spring components.



Here is the step-by-step flow when a request comes in:

1.  **Incoming Request:** A user sends an HTTP request (e.g., `GET /welcome`) to the web server.
2.  **`DispatcherServlet`:** The request first hits the `DispatcherServlet`. It acts as the traffic cop.
3.  **`HandlerMapping`:** The `DispatcherServlet` consults the **Handler Mapping** component. This component knows which **Controller** method is responsible for handling the specific URL (`/welcome`).
4.  **Controller Execution:** The request is dispatched to the appropriate **Controller** method (the handler). The Controller executes business logic (often by calling a Service), processes the input, and populates the **Model** (data).
5.  **`ViewResolver`:** The Controller returns a logical **View Name** (e.g., `"home"`). The `DispatcherServlet` then consults the **View Resolver** component. The View Resolver determines which actual view template (e.g., `home.html` or `home.jsp`) corresponds to that name.
6.  **View Rendering:** The selected **View** (e.g., a Thymeleaf template) takes the data from the **Model** and renders the final HTML output.
7.  **Response:** The rendered response (HTML, JSON, etc.) is sent back through the `DispatcherServlet` and returned to the client browser.

This centralized, component-based approach is what makes Spring MVC highly flexible, modular, and easy to test.

