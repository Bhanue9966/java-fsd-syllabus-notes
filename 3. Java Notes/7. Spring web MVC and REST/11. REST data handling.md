# üåê 7. Spring Web MVC and REST

## 11-rest-data-handling.md

### üîÑ Data Handling in REST Controllers

In a REST API, the client and server exchange data via the request body (for inputs like `POST` and `PUT`) and the response body (for outputs like `GET`). Spring uses **`HttpMessageConverter`** instances, primarily Jackson, to automatically handle the conversion between JSON/XML and Java objects.

### 1\. Handling Request Input Data (`@RequestBody`)

As previously introduced, the **`@RequestBody`** annotation is used on a method parameter to bind the entire content of the incoming HTTP request body to a specific Java object.

#### Core Concept: Deserialization

When a request arrives (e.g., `POST`), Spring uses Jackson to perform **deserialization**: converting the raw JSON string into a concrete instance of the Java class.

#### Code Example: Input Validation

Handling input data in a robust API must include **validation** to ensure data quality and prevent errors. Spring integrates seamlessly with the **Jakarta Bean Validation API (JSR 380)**, often implemented via **Hibernate Validator**.

**A. Add Annotations to the Model (Constraints)**

```java
package com.example.model;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Size;

public class ProductDto { // Data Transfer Object for input
    
    @NotBlank(message = "Product name is required.")
    @Size(min = 3, max = 50, message = "Name must be 3-50 characters.")
    private String name;
    
    @Positive(message = "Price must be a positive value.")
    private double price;
    
    // Getters and Setters...
}
```

**B. Enable Validation in the Controller**

The key to triggering validation is using the **`@Valid`** annotation (or the newer **`@jakarta.validation.Valid`**) alongside `@RequestBody`.

```java
@RestController
@RequestMapping("/api/products")
public class ProductRestController {

    @PostMapping
    public ResponseEntity<?> createProduct(
        // @Valid triggers the validation rules defined in ProductDto
        @Valid @RequestBody ProductDto productDto) 
    {
        // If validation fails, a MethodArgumentNotValidException is thrown 
        // BEFORE this line is reached.
        
        System.out.println("Validation succeeded. Creating product: " + productDto.getName());
        // Logic to convert DTO to Entity and save...
        return new ResponseEntity<>(productDto, HttpStatus.CREATED);
    }
}
```

  * **Error Handling:** When validation fails, Spring throws a **`MethodArgumentNotValidException`**. You typically handle this globally using an `@ControllerAdvice` class to return a clean `400 Bad Request` response with details about the validation failures.

-----

### 2\. Handling Response Output Data

When a controller method returns a Java object, Spring automatically converts it into the final response format.

#### Core Concept: Serialization

Spring uses Jackson to perform **serialization**: converting the Java object into a JSON string that is written to the HTTP response body.

#### Code Example: Controlling Serialization

You can use Jackson annotations on your Java object to control how it is serialized. This is particularly useful for hiding sensitive fields or changing field names.

**A. Using Jackson Annotations on the Model**

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;

public class UserDetails {
    
    // Explicitly rename the field in the JSON output
    @JsonProperty("user_identifier") 
    private Long id;
    
    private String username;
    
    // Completely hide this field from the JSON output
    @JsonIgnore 
    private String passwordHash; 
    
    // Getters and Setters...
}
```

**B. Controller Returning the Customized Object**

```java
@GetMapping("/user/{id}")
public UserDetails getUserDetails(@PathVariable Long id) {
    // Returns UserDetails object. Jackson serializes it:
    // JSON will contain "user_identifier" and "username", but NOT "passwordHash".
    return new UserDetails(id, "admin", "secret-hash-123");
}
```

#### Example Output:

```json
{
  "user_identifier": 1,
  "username": "admin"
}
```

-----

### 3\. Data Transfer Objects (DTOs)

In professional applications, the entity objects used for persistence (JPA `@Entity`) should be kept separate from the objects used for external communication (REST API).

  * **Entity:** Used for database persistence (`@Entity`). Contains all internal fields, including IDs, audit fields, etc.
  * **DTO (Data Transfer Object):** Used for REST API communication. Only contains the fields needed for a specific endpoint (input or output).

**Benefit:** Using DTOs prevents security issues (like exposing internal fields) and decouples your API contract from your database schema. The Service Layer is responsible for mapping between the DTO and the Entity.

