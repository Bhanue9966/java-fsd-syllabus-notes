# üåê 7. Spring Web MVC and REST

## 10-rest-controller.md

### üí° The `@RestController` Annotation

The `@RestController` annotation is a specialized version of the standard `@Controller` annotation. It is the fundamental component for building RESTful web services in Spring.

#### `@RestController` is a Convenience Annotation:

It is a composed annotation that combines two key annotations:

1.  **`@Controller`**: Marks the class as a web request handler.
2.  **`@ResponseBody`**: Tells Spring to skip the **View Resolution** process and instead bind the method's return value directly to the HTTP response body.

In essence, when a method in a class annotated with `@RestController` returns a Java object (like a `Product` or a `List<Product>`), Spring automatically converts that object into a transport format (usually **JSON**) and writes it straight to the response.

### 1\. JSON Conversion (The Magic)

This automatic conversion relies on **Message Converters**.

  * When you use the `spring-boot-starter-web` dependency, Spring Boot automatically includes the **Jackson library** and configures it as the default `HttpMessageConverter`.
  * Jackson handles the process of **serialization** (converting a Java object to JSON) and **deserialization** (converting JSON to a Java object).

### 2\. Code Example: Basic REST Endpoint

We will implement the basic CRUD operations for a `Product` resource using the appropriate HTTP methods.

#### **Product Model (POJO)**

```java
public class Product {
    private Long id;
    private String name;
    private double price;
    // ... Constructors, Getters, Setters (Required for Jackson)
}
```

#### **Product Controller**

```java
package com.example.api;

import com.example.model.Product;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Arrays; // Placeholder for Service/DB access

@RestController // Enables @Controller + automatic JSON conversion
@RequestMapping("/api/products") // Base URI for the resource
public class ProductRestController {

    // Placeholder data (In a real app, this comes from a Service layer)
    private List<Product> products = Arrays.asList(
        new Product(1L, "Laptop", 1500.0), 
        new Product(2L, "Mouse", 25.0)
    );

    // 1. READ (List) - GET /api/products
    @GetMapping 
    public List<Product> getAllProducts() {
        // Returns List<Product>. Jackson converts this to a JSON array.
        return products;
    }

    // 2. READ (Single) - GET /api/products/{id}
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        // Using Optional/Error Handling in a real app is best practice
        Product product = products.stream()
                                  .filter(p -> p.getId().equals(id))
                                  .findFirst()
                                  .orElse(null);

        if (product != null) {
            // Returns the Product object with status 200 OK
            return ResponseEntity.ok(product); 
        } else {
            // Returns an empty body with status 404 Not Found
            return new ResponseEntity<>(HttpStatus.NOT_FOUND); 
        }
    }

    // 3. CREATE - POST /api/products
    @PostMapping
    // @RequestBody binds the incoming JSON to the Java Product object
    // ResponseEntity allows us to explicitly set the status code (201 Created)
    public ResponseEntity<Product> createProduct(@RequestBody Product newProduct) {
        // --- Imagine save logic here: newProduct is saved, ID is generated ---
        newProduct.setId(3L); // Simulate ID assignment
        
        // Returns the created object and sets the HTTP status to 201 Created
        return new ResponseEntity<>(newProduct, HttpStatus.CREATED); 
    }
}
```

### 3\. Using `ResponseEntity<T>` for Control

While a method can simply return a `Product` (which defaults to a 200 OK status), using **`ResponseEntity<T>`** is the recommended best practice for REST controllers.

  * **Explicit Status Code:** It allows the controller to explicitly set the appropriate **HTTP Status Code** (e.g., 201 Created, 404 Not Found, 204 No Content).
  * **Custom Headers:** It allows adding custom HTTP headers to the response (e.g., location headers).

#### Example: `ResponseEntity` for DELETE

```java
// DELETE - DELETE /api/products/{id}
@DeleteMapping("/{id}")
public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
    // --- Imagine deletion logic here ---
    boolean deleted = true; // Assume success for example

    if (deleted) {
        // Returns status 204 No Content (standard for successful deletion)
        return new ResponseEntity<>(HttpStatus.NO_CONTENT); 
    } else {
        return new ResponseEntity<>(HttpStatus.NOT_FOUND); 
    }
}
```
