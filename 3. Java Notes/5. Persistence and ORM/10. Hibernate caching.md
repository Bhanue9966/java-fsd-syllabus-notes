
# ðŸ—„ï¸ Persistence and ORM

## 10. Hibernate Caching

Caching is a mechanism used to reduce the number of database trips required by an application, thereby significantly improving performance, reducing latency, and lowering the load on the database server.

### 1. The Two Levels of Caching in Hibernate ðŸ§ 

Hibernate organizes its cache into two main layers:



#### A. First-Level Cache (Session Cache)

* **Scope:** **Session** (short-lived, mandatory).
* **Behavior:** The first-level cache is active by **default** and is tied to the life cycle of a specific `Session` object.
* **Mechanism:** When you retrieve an entity within a session, Hibernate first checks this cache. If the entity is found, no database query is executed.
* **Isolation:** The cache is **not shared** between concurrent sessions. If two different sessions load the same entity, it will exist as two separate copies in memory.

| Method used | Action |
| :--- | :--- |
| `session.get()` or `session.find()` | Checks L1 cache first. |
| `session.clear()` | Clears all objects from the L1 cache. |
| `session.close()` | Automatically destroys the L1 cache. |

#### B. Second-Level Cache (SessionFactory Cache)

* **Scope:** **SessionFactory** (long-lived, optional, shared).
* **Behavior:** The second-level cache is **optional** and must be explicitly enabled and configured using an external provider (like Ehcache, Redis, or Infinispan).
* **Mechanism:** If an entity is not found in the L1 cache, Hibernate checks the L2 cache. If the entity is found here, it's served without hitting the database, and a copy is placed into the current session's L1 cache.
* **Isolation:** The cache is **shared** across all sessions created by the same `SessionFactory`. This makes it ideal for caching data that rarely changes and is frequently read.

| Requirement | Explanation |
| :--- | :--- |
| **Configuration** | Needs properties in `hibernate.cfg.xml` to enable L2 caching and specify the provider. |
| **Annotation** | Requires the `@Cacheable` annotation on the entity class. |

### 2. Query Cache (Optional) ðŸ”

The query cache is used to store the results of executed HQL or JPQL queries (e.g., a list of IDs returned by a query).

* **Dependency:** This cache is dependent on the Second-Level Cache. It cannot function without an L2 provider enabled.
* **Usage:** Must be manually enabled per query using methods like `query.setCacheable(true)`.
* **Purpose:** Stores the *keys* (IDs) returned by a query, not the entity data itself (the entity data is stored in the L2 cache).

### 3. Demonstration Summary

The code below demonstrates both levels:

1.  **L1 Demo:** We load the same `Student` twice in the *same session*. The second call hits the L1 cache, resulting in only **one** database query.
2.  **L2 Demo:** We load the `Student` in the first session, close it, and then load the same `Student` in a *new session*. If L2 caching is enabled, the second session hits the L2 cache, resulting in a DB query only on the first session.

---

Here are the complete, runnable code files:

```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

/**
 * Demonstrates Hibernate First-Level and Second-Level Caching behavior.
 * * NOTE: For L2 Caching to work, you MUST have an L2 cache provider like Ehcache 
 * configured in your pom.xml and hibernate.cfg.xml.
 */
public class CachingDemo {
    
    private static final int DEMO_ROLL_NO = 101;

    public static void main(String[] args) {

        SessionFactory sf = new Configuration()
                .configure()
                .addAnnotatedClass(Student.class)
                .buildSessionFactory();
        
        // --- SETUP: Ensure data exists ---
        try (Session session = sf.openSession()) {
             setupData(session);
        } catch (Exception e) {
             System.err.println("Setup failed: " + e.getMessage());
        }

        // ==================================================================
        // DEMO 1: FIRST-LEVEL CACHE (Session Scope)
        // ==================================================================
        System.out.println("\n=============================================");
        System.out.println("DEMO 1: FIRST-LEVEL CACHE (Same Session)");
        System.out.println("=============================================");
        
        try (Session session = sf.openSession()) {
            
            // Query 1: Hits the DB (or L2 cache, if available) and stores in L1 cache
            System.out.println("Attempt 1 (L1 Miss): ");
            Student s1 = session.find(Student.class, DEMO_ROLL_NO);
            System.out.println("Student s1 loaded: " + s1.getsName());
            
            // Query 2: Hits the L1 cache. NO database query is executed.
            System.out.println("\nAttempt 2 (L1 Hit): ");
            Student s2 = session.find(Student.class, DEMO_ROLL_NO);
            System.out.println("Student s2 loaded: " + s2.getsName());
            
            // Confirmation: Both objects refer to the same object instance in memory
            System.out.println("\nSame instance check: " + (s1 == s2));
            
        } catch (Exception e) {
            System.err.println("âŒ L1 Demo failed: " + e.getMessage());
        }
        
        
        // ==================================================================
        // DEMO 2: SECOND-LEVEL CACHE (SessionFactory Scope)
        // ==================================================================
        System.out.println("\n=============================================");
        System.out.println("DEMO 2: SECOND-LEVEL CACHE (Different Sessions)");
        System.out.println("=============================================");
        
        // --- Session 1: Populates L2 Cache ---
        try (Session session1 = sf.openSession()) {
            System.out.println("--- Session 1: Initial Load (DB -> L2) ---");
            // Hits DB (L2 Miss). Entity data is stored in L2 cache upon commit/close.
            session1.find(Student.class, DEMO_ROLL_NO); 
        } // Session 1 closes. L1 cache is destroyed, L2 cache retains data.

        // --- Session 2: Hits L2 Cache ---
        try (Session session2 = sf.openSession()) {
            // L1 Miss, L2 Hit. Entity is loaded from shared L2 cache. NO DB query runs.
            System.out.println("\n--- Session 2: Subsequent Load (L2 Hit) ---");
            Student s3 = session2.find(Student.class, DEMO_ROLL_NO);
            System.out.println("Student s3 loaded: " + s3.getsName());
            System.out.println("If this was successful without a DB query, L2 cache is working.");
        } 
        
        if (sf != null) {
            sf.close();
            System.out.println("\nSessionFactory closed.");
        }
    }
    
    // Helper method to ensure the data exists for the demo
    private static void setupData(Session session) {
        Transaction tx = session.beginTransaction();
        
        Student s = new Student(DEMO_ROLL_NO, "Cache Tester", 30);
        
        session.merge(s); // Persist or update
        
        tx.commit();
        System.out.println("Sample data setup complete (RollNo " + DEMO_ROLL_NO + ").");
    }
}
```