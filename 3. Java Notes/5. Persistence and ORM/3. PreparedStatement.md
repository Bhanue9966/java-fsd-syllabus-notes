# üóÑÔ∏è Persistence and ORM

## 3\. PreparedStatement

The **`PreparedStatement`** interface extends `Statement` and is used to execute precompiled SQL queries that can accept runtime input parameters. It is the recommended approach for executing dynamic SQL statements in JDBC.

### 1\. Why Use `PreparedStatement`? üõ°Ô∏èüöÄ

| Benefit | `PreparedStatement` | `Statement` |
| :--- | :--- | :--- |
| **Security** | **Prevents SQL Injection attacks** because user input is treated only as data, not executable SQL code. | **Vulnerable** to SQL Injection as input is concatenated directly into the SQL string. |
| **Performance** | The database compiles the SQL query once (the execution plan is cached). Subsequent executions with different parameters are much faster. | The database must parse, compile, and execute the SQL query on every call. |
| **Readability** | Cleaner code when handling dynamic parameters. | Messy and error-prone string concatenation. |

### 2\. Implementation: Using Placeholders (`?`)

When using `PreparedStatement`, you replace dynamic values in the SQL string with **placeholder question marks (`?`)**. The values are then bound to these placeholders using `setXXX()` methods.

#### Example Code Implementation (Modified from Previous)

We will use the `try-with-resources` construct (Section 8) to ensure the `Connection` and `PreparedStatement` are closed automatically.

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement; // Still needed for raw SQL if necessary

public class PreparedStatementDemo {
    public static void main(String[] args) throws Exception {
        
        String url = "jdbc:postgresql://localhost:5432/demo";
        String uname = "postgres";
        String pass = "6031";
        
        // 1. SQL uses '?' placeholders instead of literal values
        String sql_insert = "INSERT INTO student (s_id, s_name, s_marks) VALUES (?, ?, ?)";
        
        // Use try-with-resources for automatic cleanup
        try (Connection con = DriverManager.getConnection(url, uname, pass);
             // 2. PREPARE the statement (Database caches the query structure)
             PreparedStatement ps = con.prepareStatement(sql_insert)) {
            
            System.out.println("Connection and PreparedStatement prepared.");

            // --- Execution 1: Inserting Alice ---
            // 3. BIND the parameters (1-based index)
            ps.setInt(1, 105);      // Sets the first '?' to 105 (int)
            ps.setString(2, "Frank"); // Sets the second '?' to "Frank" (String)
            ps.setInt(3, 78);       // Sets the third '?' to 78 (int)

            // 4. EXECUTE the statement (no SQL argument needed)
            int countInsert = ps.executeUpdate();
            System.out.println("Inserted Frank: " + countInsert + " row(s).");
            
            // --- Execution 2: Inserting Grace (Re-using the prepared statement) ---
            // This second execution is much faster as the SQL is already compiled.
            ps.setInt(1, 106);
            ps.setString(2, "Grace");
            ps.setInt(3, 88);
            countInsert = ps.executeUpdate();
            System.out.println("Inserted Grace: " + countInsert + " row(s).");

            // ... (A separate Statement or PreparedStatement would be needed for SELECT)
            
        } catch (Exception e) {
            e.printStackTrace();
        } 
        System.out.println("Connection closed automatically.");
    }
}
```

### 3\. Key Steps with `PreparedStatement`

1.  **Define SQL with Placeholders:** Write the SQL query with `?` as placeholders for the dynamic values.
2.  **Prepare Statement:** Use `Connection.prepareStatement(sql)` to create the `PreparedStatement` object. This sends the SQL template to the database for parsing and compilation.
3.  **Bind Parameters:** Use the appropriate **`ps.setXXX(int index, value)`** method (e.g., `setInt`, `setString`, `setDate`, etc.) to substitute values for the placeholders. The index is **1-based**.
4.  **Execute:** Execute the prepared statement using methods like **`ps.executeUpdate()`** or **`ps.executeQuery()`**. You **do not** pass the SQL string again.

### 4\. Preventing SQL Injection (Security Focus)

Consider a login scenario with regular `Statement`:

```java
// VULNERABLE STATEMENT
String user = getUserInput(); // user might input: " ' OR 1=1 -- "
String sql = "SELECT * FROM users WHERE username = '" + user + "'"; // SQL is now injected!
```

With `PreparedStatement`, the user input is *always* treated as a string literal and cannot be executed as SQL code, thus preventing the attack:

```java
// SECURE PREPAREDSTATEMENT
String sql = "SELECT * FROM users WHERE username = ?";
PreparedStatement ps = con.prepareStatement(sql);
ps.setString(1, user); // User input is safely quoted and treated as data.
```

