# üóÑÔ∏è Persistence and ORM

## 8. Hibernate Mapping Types (1:M and M:M)

### 1. One-to-Many (1:M) / Many-to-One (M:1)

This is the most common relationship type. It represents a parent-child relationship where one parent entity can have multiple child entities, but each child has only one parent.

#### A. Database Structure

* **Parent Table (One Side):** (e.g., `department`) has a Primary Key.
* **Child Table (Many Side):** (e.g., `employee`) has a Primary Key and a **Foreign Key (FK)** column that references the parent table's Primary Key.


![DBMS mappings](<DBMS mappings.jpg>)


#### B. Hibernate Mapping (Bidirectional)

| Annotation | Location | Role |
| :--- | :--- | :--- |
| `@ManyToOne` | On the Child Entity (`Employee.department`) | **Owning Side.** This is where the Foreign Key is physically stored in the database. |
| `@JoinColumn` | With `@ManyToOne` on the Child | Specifies the name of the Foreign Key column (`dept_fk`) in the child table. |
| `@OneToMany` | On the Parent Entity (`Department.employees`) | **Inverse Side.** This side is mapped by the field on the Child. |
| `mappedBy="field"` | With `@OneToMany` on the Parent | Specifies the field name on the *other* (owning) side that manages the relationship. |

#### C. Code Example: Department (1) and Employee (M)


```java
package com.telusko;

import jakarta.persistence.*;
import java.util.List;
import java.util.ArrayList;

@Entity
public class Department {
    
    @Id
    private int deptId;
    private String deptName;
    
    // OneToMany mapping: A Department can have many Employees.
    // mappedBy="department" means the 'department' field in the Employee class 
    // is responsible for the foreign key.
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
    private List<Employee> employees = new ArrayList<>();

    // Constructors and Getters/Setters
    public Department() {}
    public Department(int deptId, String deptName) {
        this.deptId = deptId;
        this.deptName = deptName;
    }

    public int getDeptId() { return deptId; }
    public void setDeptId(int deptId) { this.deptId = deptId; }
    public String getDeptName() { return deptName; }
    public void setDeptName(String deptName) { this.deptName = deptName; }
    public List<Employee> getEmployees() { return employees; }
    public void setEmployees(List<Employee> employees) { this.employees = employees; }

    @Override
    public String toString() {
        return "Department [id=" + deptId + ", name=" + deptName + "]";
    }
}
```

```java
package com.telusko;

import jakarta.persistence.*;

@Entity
public class Employee {
    
    @Id
    private int empId;
    private String empName;
    
    // ManyToOne mapping: Many Employees belong to one Department.
    // This is the Owning Side (Foreign Key is here).
    @ManyToOne 
    @JoinColumn(name = "dept_fk") // Specifies the actual FK column in the 'employee' table
    private Department department;

    // Constructors and Getters/Setters
    public Employee() {}
    public Employee(int empId, String empName) {
        this.empId = empId;
        this.empName = empName;
    }

    public int getEmpId() { return empId; }
    public void setEmpId(int empId) { this.empId = empId; }
    public String getEmpName() { return empName; }
    public void setEmpName(String empName) { this.empName = empName; }
    public Department getDepartment() { return department; }
    public void setDepartment(Department department) { this.department = department; }

    @Override
    public String toString() {
        return "Employee [id=" + empId + ", name=" + empName + "]";
    }
}
```

```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import java.util.Arrays;

public class OneToManyDemo {
    public static void main(String[] args) {

        SessionFactory sf = new Configuration()
                .configure()
                .addAnnotatedClass(Department.class)
                .addAnnotatedClass(Employee.class)
                .buildSessionFactory();

        try (Session session = sf.openSession()) {
            Transaction transaction = session.beginTransaction();

            // 1. Create Parent and Child entities
            Department hr = new Department(10, "Human Resources");
            Employee e1 = new Employee(1, "Alice");
            Employee e2 = new Employee(2, "Bob");
            
            // 2. Link the relationship bidirectionally (Crucial step!)
            e1.setDepartment(hr);
            e2.setDepartment(hr);
            
            hr.setEmployees(Arrays.asList(e1, e2));

            // 3. Persist (Saving the parent cascades the save to the children due to CascadeType.ALL)
            session.persist(hr);

            transaction.commit();
            
            // 4. Read (Demonstrate fetching the relationship)
            session.clear(); // Clear session cache to force DB read
            Department retrievedDept = session.find(Department.class, 10);
            
            System.out.println("-----------------------------------");
            System.out.println("‚úÖ Department Retrieved: " + retrievedDept);
            // Employees will be lazily loaded by default
            System.out.println("   Associated Employees: " + retrievedDept.getEmployees());
            System.out.println("-----------------------------------");

        } catch (Exception e) {
            System.err.println("‚ùå Error during One-to-Many operation: " + e.getMessage());
        } finally {
            if (sf != null) sf.close();
        }
    }
}
```
### 2. Many-to-Many (M:M)

This relationship is used when multiple instances of Entity A can be related to multiple instances of Entity B.

#### A. Database Structure

A Many-to-Many relationship **cannot** be represented by a simple Foreign Key. It requires a third table, known as a **Join Table** or **Association Table**, which contains two composite Foreign Keys‚Äîone for each linked entity.



#### B. Hibernate Mapping

You only need to define the relationship on one side (the owning side) using the `@ManyToMany` annotation.

| Annotation | Location | Purpose |
| :--- | :--- | :--- |
| `@ManyToMany` | On both Entity A and Entity B | Specifies the relationship type. |
| `@JoinTable` | On the Owning Side (arbitrarily chosen) | **Crucial:** Defines the name of the intermediary join table and the names of the two foreign key columns within that table. |

#### C. Code Example: Developer (M) and Project (M)


```java
package com.telusko;

import jakarta.persistence.*;
import java.util.List;
import java.util.ArrayList;

@Entity
public class Developer {
    
    @Id
    private int devId;
    private String devName;
    
    // ManyToMany mapping: A Developer can work on many Projects.
    // This is the Owning Side: it defines the join table structure.
    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(
        name = "dev_project", // Name of the intermediary join table
        joinColumns = @JoinColumn(name = "developer_id"), // FK column for this entity (Developer)
        inverseJoinColumns = @JoinColumn(name = "project_id") // FK column for the other entity (Project)
    )
    private List<Project> projects = new ArrayList<>();

    // Constructors and Getters/Setters
    public Developer() {}
    public Developer(int devId, String devName) {
        this.devId = devId;
        this.devName = devName;
    }
    
    // ... Getters and Setters

    public int getDevId() { return devId; }
    public void setDevId(int devId) { this.devId = devId; }
    public String getDevName() { return devName; }
    public void setDevName(String devName) { this.devName = devName; }
    public List<Project> getProjects() { return projects; }
    public void setProjects(List<Project> projects) { this.projects = projects; }

    @Override
    public String toString() {
        return "Developer [id=" + devId + ", name=" + devName + "]";
    }
}
```

```java
package com.telusko;

import jakarta.persistence.*;
import java.util.List;
import java.util.ArrayList;

@Entity
public class Project {
    
    @Id
    private int projId;
    private String projName;
    
    // ManyToMany mapping: A Project can have many Developers.
    // This is the Inverse Side: mappedBy points to the field in the owning class.
    @ManyToMany(mappedBy = "projects") 
    private List<Developer> developers = new ArrayList<>();

    // Constructors and Getters/Setters
    public Project() {}
    public Project(int projId, String projName) {
        this.projId = projId;
        this.projName = projName;
    }

    // ... Getters and Setters

    public int getProjId() { return projId; }
    public void setProjId(int projId) { this.projId = projId; }
    public String getProjName() { return projName; }
    public void setProjName(String projName) { this.projName = projName; }
    public List<Developer> getDevelopers() { return developers; }
    public void setDevelopers(List<Developer> developers) { this.developers = developers; }

    @Override
    public String toString() {
        return "Project [id=" + projId + ", name=" + projName + "]";
    }
}
```

```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import java.util.Arrays;

public class ManyToManyDemo {
    public static void main(String[] args) {

        SessionFactory sf = new Configuration()
                .configure()
                .addAnnotatedClass(Developer.class)
                .addAnnotatedClass(Project.class)
                .buildSessionFactory();

        try (Session session = sf.openSession()) {
            Transaction transaction = session.beginTransaction();

            // 1. Create Entities
            Developer d1 = new Developer(101, "John");
            Developer d2 = new Developer(102, "Sara");

            Project p1 = new Project(5001, "E-Commerce Site");
            Project p2 = new Project(5002, "Mobile App");

            // 2. Link the relationship
            // John works on E-Commerce and Mobile App
            d1.getProjects().add(p1);
            d1.getProjects().add(p2);

            // Sara works only on E-Commerce Site
            d2.getProjects().add(p1);
            
            // Link the inverse side for consistency (optional but good practice)
            p1.getDevelopers().add(d1);
            p1.getDevelopers().add(d2);
            p2.getDevelopers().add(d1);

            // 3. Persist (Saving the developers cascades the save to the projects and the join table)
            session.persist(d1);
            session.persist(d2);
            session.persist(p1);
            session.persist(p2);

            transaction.commit();
            
            // 4. Read (Demonstrate fetching the relationship)
            session.clear(); // Clear cache
            Developer retrievedDev = session.find(Developer.class, 101);
            
            System.out.println("-----------------------------------");
            System.out.println("‚úÖ Developer Retrieved: " + retrievedDev);
            // Accessing the related projects
            System.out.println("   Working on Projects: " + retrievedDev.getProjects()); 
            System.out.println("-----------------------------------");


        } catch (Exception e) {
            System.err.println("‚ùå Error during Many-to-Many operation: " + e.getMessage());
        } finally {
            if (sf != null) sf.close();
        }
    }
}
```

