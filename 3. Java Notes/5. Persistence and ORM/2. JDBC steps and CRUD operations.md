# üóÑÔ∏è Persistence and ORM

## 2\. JDBC Steps: CRUD Operations

While the connection steps remain the same as in the previous file, the core difference between the CRUD operations is the **execution method** used in **Step 5** and how the result is processed in **Step 6**.

We categorize database operations into two types:

1.  **Read Operations (DQL/Select):** Uses `st.executeQuery()` and returns a `ResultSet`.
2.  **Modification Operations (DML/Insert, Update, Delete):** Uses `st.executeUpdate()` and returns an `int` count of affected rows.

### Example Code Implementation (CRUD)

We will use the same connection parameters and demonstrate four different SQL operations.

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class JdbcCrudDemo {
    public static void main(String[] args) throws Exception {
        
        String url = "jdbc:postgresql://localhost:5432/demo";
        String uname = "postgres";
        String pass = "6031";
        
        // 1. Connection Setup (Steps 1, 2, 3)
        Connection con = DriverManager.getConnection(url, uname, pass);
        Statement st = con.createStatement();
        System.out.println("Connection established.");

        // --- 1. CREATE Operation (INSERT) ---
        String sql_insert = "INSERT INTO student (s_id, s_name, s_marks) VALUES (104, 'Eve', 85)";
        int countInsert = st.executeUpdate(sql_insert);
        System.out.println("Inserted " + countInsert + " row(s).");

        // --- 2. UPDATE Operation (UPDATE) ---
        String sql_update = "UPDATE student SET s_marks = 92 WHERE s_id = 101";
        int countUpdate = st.executeUpdate(sql_update);
        System.out.println("Updated " + countUpdate + " row(s).");
        
        // --- 3. READ Operation (SELECT) ---
        // Your original code structure is used here:
        String sql_select = "SELECT s_id, s_name, s_marks FROM student";
        ResultSet rs = st.executeQuery(sql_select); 
        
        System.out.println("\n--- Current Student Data ---");
        while (rs.next()){
            // Retrieve by column index (1-based) or column name
            int id = rs.getInt(1); 
            String name = rs.getString("s_name"); 
            int marks = rs.getInt(3);

            System.out.println(id + " | " + name + " | " + marks);
        }
        
        // --- 4. DELETE Operation (DELETE) ---
        String sql_delete = "DELETE FROM student WHERE s_id = 104";
        int countDelete = st.executeUpdate(sql_delete);
        System.out.println("\nDeleted " + countDelete + " row(s).");

        // 5. Cleanup (Step 7)
        con.close();
        System.out.println("Connection closed.");
    }
}
```

-----

### Execution Details: `executeQuery()` vs. `executeUpdate()`

| Operation Type | SQL Commands | JDBC Method | Return Type | Description |
| :--- | :--- | :--- | :--- | :--- |
| **Read (Query)** | `SELECT` | **`st.executeQuery(sql)`** | `ResultSet` | Retrieves data; requires iterating through the cursor. |
| **Modification (DML)** | `INSERT`, `UPDATE`, `DELETE` | **`st.executeUpdate(sql)`** | `int` | Modifies the database state; the integer returned is the number of rows affected by the command. |

#### **Modification Example Analysis (`INSERT`, `UPDATE`, `DELETE`):**

In the example above, for the DML operations (`INSERT`, `UPDATE`, `DELETE`):

```java
int countInsert = st.executeUpdate(sql_insert);
// countInsert will be 1 if the row was successfully added.
```

The method returns an **integer count** because these statements do not return data; they report on the extent of the change they made to the database. We use this count to confirm the operation's success.

