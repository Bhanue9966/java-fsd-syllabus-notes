My apologies! Thank you for correcting me on the syllabus sequence. We will now proceed exactly as you outlined, starting with the theoretical foundation for Hibernate mapping.

I must reiterate that while I will put the full, clear explanation in the Markdown file, the runnable Java code *must* be delivered in the required file blocks (`.java` files) so you can run, test, and edit them in your environment. I cannot deliver executable code directly in the chat, but I promise the explanation and the code structure will be complete.

Here are the notes for **`07-hibernate-mapping-theory.md`**, followed by the necessary code to illustrate the concepts.

---

# üóÑÔ∏è Persistence and ORM

## 7. Hibernate Mapping Theory

This file lays the theoretical groundwork for how Hibernate manages data persistence, focusing on the Entity lifecycle and the fundamental types of object-relational relationships.

### 1. Entity States (The Entity Lifecycle) üîÑ

An Entity instance in Hibernate can exist in one of three states. Understanding these states is crucial for knowing when changes are synchronized with the database.



| State | Description | Example |
| :--- | :--- | :--- |
| **Transient** | The object is newly created using `new()`, but has **no relationship** with a Hibernate `Session` and no representation in the database. | `Student s = new Student();` |
| **Persistent** | The object is associated with a unique Hibernate `Session`. Any changes to a persistent object (within a transaction) are automatically detected and synchronized with the database when the transaction is committed (**Dirty Checking**). | `session.find(Student.class, 101);` |
| **Detached** | The object was once persistent, but the `Session` it was associated with has been closed or cleared. Changes to a detached object are **not** synchronized until it is re-attached (using `session.merge()`). | After `session.close()`, the retrieved object becomes detached. |

### 2. Object-Relational Mapping (ORM) Theory

ORM is the process of defining relationships between Java objects and translating them into database structures (foreign keys). The four types of relationships in Java are also represented in the database world.

| Relationship | Description | Database Representation | Hibernate Annotation |
| :--- | :--- | :--- | :--- |
| **One-to-One (1:1)** | A single instance of Entity A is associated with exactly one instance of Entity B. | A foreign key on one of the tables (often the child/dependent entity). | `@OneToOne` |
| **One-to-Many (1:M)** | A single instance of Entity A is associated with multiple instances of Entity B. | A foreign key in the 'many' side (Entity B) that references the 'one' side (Entity A). | `@OneToMany` (on A), `@ManyToOne` (on B) |
| **Many-to-One (M:1)** | This is the inverse side of 1:M. Many instances of Entity A map to one instance of Entity B. | Same as 1:M: A foreign key in the 'many' side (Entity A). | `@ManyToOne` |
| **Many-to-Many (M:M)** | Many instances of Entity A are associated with many instances of Entity B. | An intermediary **Join Table** (or bridge table) with composite foreign keys to both A and B. | `@ManyToMany` |

### 3. Example: One-to-One Mapping (Student ‚Üî Laptop)

We will illustrate the simplest relationship, **One-to-One**, where a `Student` entity is mapped to a `Laptop` entity.

* **Student Entity:** Has a field referencing `Laptop`.
* **Laptop Entity:** Has a foreign key column (`student_fk`) pointing back to the `Student`'s primary key.

#### Key Mapping Annotations

1.  **`@OneToOne`**: Specifies the relationship type.
2.  **`@JoinColumn`**: Used to specify the foreign key column that links the two tables.

#### Code Illustration:

The following code defines the two entities and demonstrates persisting them together.

```java
package com.telusko;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;

@Entity
public class Laptop {
    
    @Id
    private int lid;
    private String brand;
    private int price;
    
    // 1. One-to-One mapping: This laptop belongs to one student.
    // @JoinColumn specifies the foreign key column in the 'laptop' table 
    // that references the 'student' table's primary key.
    @OneToOne
    @JoinColumn(name = "student_fk") // The FK column in the 'laptop' table
    private Student student; // The object reference to the Student

    // Constructors (omitted for brevity)
    public Laptop() {}

    // Getters and Setters
    public int getLid() { return lid; }
    public void setLid(int lid) { this.lid = lid; }
    public String getBrand() { return brand; }
    public void setBrand(String brand) { this.brand = brand; }
    public int getPrice() { return price; }
    public void setPrice(int price) { this.price = price; }
    public Student getStudent() { return student; }
    public void setStudent(Student student) { this.student = student; }

    @Override
    public String toString() {
        return "Laptop [lid=" + lid + ", brand=" + brand + ", price=" + price + "]";
    }
}
```


```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

/**
 * Demonstrates persisting a One-to-One relationship between Student and Laptop.
 * This requires the entities to be correctly annotated and registered.
 */
public class StudentMappingDemo {
    public static void main(String[] args) {

        SessionFactory sf = new Configuration()
                .configure()
                .addAnnotatedClass(Student.class)
                .addAnnotatedClass(Laptop.class)
                .buildSessionFactory();

        final int DEMO_ROLL_NO = 112;
        final int DEMO_LAPTOP_ID = 501;

        try (Session session = sf.openSession()) {
            Transaction transaction = null;

            // ==================================================================
            // A. PERSISTING THE RELATIONSHIP
            // ==================================================================
            try {
                transaction = session.beginTransaction();
                
                // 1. Create the objects
                Student student = new Student(DEMO_ROLL_NO, "Rahul Dravid", 45);
                Laptop laptop = new Laptop();
                laptop.setLid(DEMO_LAPTOP_ID);
                laptop.setBrand("Dell");
                laptop.setPrice(120000);
                
                // 2. Map the relationship bidirectionally (Crucial step!)
                student.setLaptop(laptop);
                laptop.setStudent(student);
                
                // 3. Save the objects. 
                // We save Laptop first as it contains the FK (student_fk).
                session.persist(laptop); 
                session.persist(student);
                
                transaction.commit();
                System.out.println("‚úÖ Relationship saved successfully.");
            } catch (Exception e) {
                if (transaction != null) transaction.rollback();
                System.err.println("‚ùå CREATE failed: " + e.getMessage());
            }

            // ==================================================================
            // B. READING THE RELATIONSHIP
            // ==================================================================
            System.out.println("\n--- READING RELATED DATA ---");
            Student retrievedStudent = session.find(Student.class, DEMO_ROLL_NO);
            
            if (retrievedStudent != null) {
                System.out.println("Student: " + retrievedStudent);
                // Accessing the related Laptop object
                System.out.println("Related Laptop: " + retrievedStudent.getLaptop()); 
            }

        } finally {
            if (sf != null) {
                sf.close();
                System.out.println("\nSession and SessionFactory closed.");
            }
        }
    }
}
```