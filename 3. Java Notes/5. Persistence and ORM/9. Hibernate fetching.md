# üóÑÔ∏è Persistence and ORM

## 9\. Hibernate Fetching Strategies (Lazy vs. Eager)

Fetching refers to how Hibernate loads related entities (associations) when you retrieve the main entity from the database. Choosing the correct strategy is vital to application performance.

### 1\. The Core Concept üöÄ

When you load a parent object (e.g., a `Department`), should all its children (`Employees`) be loaded immediately, or only when you specifically call the getter method on the child collection?

### 2\. Lazy Loading (`FetchType.LAZY`)

This is the **default** behavior for collection mappings (`@OneToMany`, `@ManyToMany`).

| Feature | Description | Performance Implication |
| :--- | :--- | :--- |
| **Execution** | The related data (e.g., `employees` list) is **not** loaded when the parent `Department` is retrieved. The list is replaced by a proxy object. | Excellent, low-overhead initial load. Uses minimal memory. |
| **Data Access** | Data is loaded only when you explicitly access the collection (e.g., calling `department.getEmployees()`). | Can lead to the **N+1 Select Problem** if accessed inefficiently in a loop. |
| **Transaction** | If you access the lazy-loaded collection after the `Session` is closed, a `LazyInitializationException` occurs. |

### 3\. Eager Loading (`FetchType.EAGER`)

This is the **default** behavior for single-valued association mappings (`@OneToOne`, `@ManyToOne`).

| Feature | Description | Performance Implication |
| :--- | :--- | :--- |
| **Execution** | The related data is loaded **immediately** along with the parent entity, typically using a single `JOIN` SQL query. | Higher overhead on initial load, but fewer overall database hits. |
| **Data Access** | The data is available immediately, even after the `Session` is closed (if loaded successfully). | Can lead to unnecessary data transfer and increased memory usage if the related data is large and seldom used. |

### 4\. The N+1 Select Problem ‚ö†Ô∏è

This is the most common performance trap in ORM frameworks. It occurs when using **Lazy Loading** in a loop:

  * **N+1 Queries:**
    1.  **1 Query:** Selects N parent entities (e.g., all 100 Departments).
    2.  **N Queries:** For each parent entity (N=100), Hibernate executes a separate query to fetch its child collection (e.g., all Employees for that Department) when the collection is accessed in the loop.

This results in 101 unnecessary database round trips, severely impacting application speed.

### 5\. Solution: `JOIN FETCH` (HQL/JPQL)

To solve the N+1 problem while retaining control, the best practice is to override the default fetching behavior using a dedicated query:

```sql
-- Instead of 101 queries, this runs 1 optimized query:
SELECT d FROM Department d JOIN FETCH d.employees WHERE d.id = :id 
```

This forces Hibernate to load the association eagerly within the scope of that single query.

-----

Here are the updated entity and the demonstration code:

```java
package com.telusko;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import java.util.Arrays;

public class FetchingDemo {
    
    private static final int DEMO_DEPT_ID = 20;

    public static void main(String[] args) {

        SessionFactory sf = new Configuration()
                .configure()
                .addAnnotatedClass(Department.class)
                .addAnnotatedClass(Employee.class)
                .buildSessionFactory();
        
        // --- SETUP: Persist sample data first ---
        try (Session session = sf.openSession()) {
             setupData(session);
        } catch (Exception e) {
             System.err.println("Setup failed: " + e.getMessage());
        }


        // --- DEMO 1: LAZY LOADING (Default for Collections) ---
        System.out.println("\n=============================================");
        System.out.println("DEMO 1: LAZY LOADING (Default Behavior)");
        System.out.println("=============================================");
        
        try (Session session = sf.openSession()) {
            
            // 1. Fetch the Department. SQL: SELECT * FROM department WHERE deptId = 20;
            // The employees list is loaded as a PROXY.
            System.out.println("--- 1. Executing find(Department) ---");
            Department dept = session.find(Department.class, DEMO_DEPT_ID);
            System.out.println("Result: Department retrieved. Employees list is a proxy object.");
            
            // 2. Access the Employees collection. This triggers the second query.
            // SQL: SELECT * FROM employee WHERE dept_fk = 20;
            System.out.println("\n--- 2. Accessing dept.getEmployees() ---");
            System.out.println("Employees size: " + dept.getEmployees().size()); 
            System.out.println("Result: Second query executed to load employees on demand.");
            
        } catch (Exception e) {
            System.err.println("‚ùå Lazy Demo failed: " + e.getMessage());
        }
        
        
        // --- DEMO 2: LazyInitializationException (Accessing data after Session close) ---
        System.out.println("\n=============================================");
        System.out.println("DEMO 2: LazyInitializationException");
        System.out.println("=============================================");
        
        Department detachedDept = null;
        try (Session session = sf.openSession()) {
            // 1. Fetch the Department object.
            detachedDept = session.find(Department.class, DEMO_DEPT_ID);
            System.out.println("Department retrieved within session.");
        } // Session closes here. 'detachedDept' is now Detached.

        // 2. Try to access the lazy collection after the session is closed
        try {
            System.out.println("Attempting to access employees on a closed session object...");
            detachedDept.getEmployees().size();
        } catch (Exception e) {
            // This is the expected behavior for Lazy-loaded collections outside an active session
            System.out.println("‚úÖ Caught Expected Error: " + e.getClass().getSimpleName());
            System.out.println("Reason: Cannot initialize proxy - no Session active.");
        }


        if (sf != null) {
            sf.close();
            System.out.println("\nSessionFactory closed.");
        }
    }
    
    // Helper method to ensure the data exists for the demo
    private static void setupData(Session session) {
        Transaction tx = session.beginTransaction();
        
        Department dept = new Department(DEMO_DEPT_ID, "Engineering");
        Employee e1 = new Employee(100, "Mark");
        Employee e2 = new Employee(101, "Lisa");
        
        e1.setDepartment(dept);
        e2.setDepartment(dept);
        dept.setEmployees(Arrays.asList(e1, e2));
        
        // Use merge/persist to handle cases where data might already exist
        session.merge(dept); 
        
        tx.commit();
        System.out.println("Sample data setup complete (Dept ID 20).");
    }
}
```
