# ⚙️ Spring Core and Boot

## 1\. Spring Introduction, IoC, and DI

### 1\. Introduction to the Spring Framework

Spring is the leading application development framework for enterprise Java. It provides comprehensive infrastructure support, allowing you to focus on the application-level business logic.

#### Why Spring?

1.  **Loose Coupling:** Spring promotes loose coupling by managing object creation and dependency injection.
2.  **Modularity:** Its structure allows you to use specific modules (e.g., Spring Core, Spring Data, Spring MVC) without needing the rest.
3.  **Portability:** It doesn't force you to stick to one specific environment.
4.  **Testing:** It makes unit and integration testing easier because objects are loosely coupled.

### 2\. Inversion of Control (IoC)

In traditional Java development, you are responsible for creating objects and managing their dependencies.

```java
// Traditional Control Flow (The user controls creation)
public class Alien {
    private Laptop laptop = new Laptop(); // You create the dependency
}
```

**Inversion of Control (IoC)** is a principle where the framework takes over the responsibility of creating and managing objects.

  * **Inversion:** Instead of the developer creating the object, the object's creation and lifecycle management are delegated to the **IoC Container**.
  * **IoC Container:** This is the core of the Spring Framework (often called the `ApplicationContext`). It manages the lifecycle of Java objects, known as **Beans**.

### 3\. Dependency Injection (DI)

Dependency Injection is a specific pattern used to achieve IoC. It describes the mechanism by which the IoC container "injects" dependencies into an object when it's created, rather than the object creating them itself.

#### The Role of DI:

If an `Alien` class needs a `Laptop` object, the Spring container performs the following steps:

1.  Creates the `Laptop` object (the dependency).
2.  Creates the `Alien` object (the dependent).
3.  Injects the `Laptop` object into the `Alien` object.

#### Types of Dependency Injection:

| Type | Mechanism | Annotation Example |
| :--- | :--- | :--- |
| **Constructor Injection** | Dependencies are provided through the class constructor. (Recommended for mandatory dependencies.) | `@Autowired` above the constructor. |
| **Setter Injection** | Dependencies are provided through public setter methods. (Good for optional dependencies.) | `@Autowired` above the setter method. |
| **Field Injection** | Dependencies are injected directly into the field using reflection. (Simplest syntax, but less recommended for large apps.) | `@Autowired` above the field. |

The example code below demonstrates **Field Injection** using the `@Autowired` annotation, which tells the IoC Container to inject the dependency.

-----

Here are the Java files demonstrating IoC and DI:

```java
package com.telusko;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * The Dependent (Alien)
 * It needs the Laptop object to perform its work (code).
 */
@Component // Makes Alien a Spring Bean
public class Alien {
    
    private int aid = 1;
    private String name = "Navin";
    
    // Dependency Injection (DI) via Field Injection:
    // @Autowired tells Spring's IoC container to find a bean of type Laptop 
    // and inject it into this field, inverting the control of object creation.
    @Autowired 
    private Laptop laptop;

    public void code() {
        System.out.println("Alien " + name + " is coding...");
        if (laptop != null) {
            laptop.compile();
        } else {
            System.out.println("No laptop injected! (DI failed)");
        }
    }

    // Getters and Setters (omitted for brevity)
    public int getAid() { return aid; }
    public void setAid(int aid) { this.aid = aid; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public Laptop getLaptop() { return laptop; }
    public void setLaptop(Laptop laptop) { this.laptop = laptop; }
}
```

```java
package com.telusko;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

/**
 * Java Configuration Class
 * This replaces the older XML configuration files.
 */
@Configuration
// This annotation tells the Spring IoC Container where to scan for classes 
// annotated with @Component, @Autowired, etc.
@ComponentScan("com.telusko") 
public class AppConfig {
    
    // No manual bean definitions needed here, as we are relying on ComponentScan and annotations.
}
```

```java
package com.telusko;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class App {
    public static void main(String[] args) {
        
        // 1. Initialize the Spring IoC Container (ApplicationContext)
        // This is the framework that manages all the beans (Alien and Laptop).
        System.out.println("--- 1. IoC Container Initialization ---");
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        
        System.out.println("--- 2. Retrieving Alien Bean from Container ---");
        // 2. Request the 'Alien' bean from the container. 
        // The container creates Alien, creates Laptop, and injects Laptop into Alien.
        Alien alien = context.getBean(Alien.class);
        
        // 3. Use the Alien object with its injected dependency
        System.out.println("--- 3. Using the Injected Dependency (Alien calls Laptop.compile()) ---");
        alien.code();
        
        System.out.println("\nSuccessfully demonstrated Dependency Injection via @Autowired.");
        
        ((AnnotationConfigApplicationContext) context).close(); 
    }
}
```