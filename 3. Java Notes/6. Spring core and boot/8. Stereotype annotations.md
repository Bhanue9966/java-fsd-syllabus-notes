# ‚öôÔ∏è 6. Spring Core and Boot

## 08-stereotype-annotations.md

### üè∑Ô∏è Stereotype Annotations

Stereotype annotations are special annotations used to mark Java classes as Spring components. When the Spring container performs component scanning (`@ComponentScan`), it automatically detects these classes and registers them as beans.

All stereotype annotations are, at their core, specializations of the fundamental annotation: **`@Component`**.

-----

### 1\. `@Component`

This is the most generic stereotype annotation. It marks a class as a plain Spring component.

  * **Purpose:** To signal to Spring that a class is a candidate for auto-detection and should be created as a bean.
  * **Usage:** Use this when a class serves a general purpose and doesn't fit into the more specific layers (like web, service, or data).

#### Code Example

**`src/main/java/com/example/annotations/MyGenericComponent.java`**

```java
package com.example.annotations;

import org.springframework.stereotype.Component;

@Component
public class MyGenericComponent {
    public void printMessage() {
        System.out.println("This is a generic component bean.");
    }
}
```

-----

### 2\. Layer-Specific Stereotypes

To improve code readability, make configuration clearer, and enable special features (like exception translation in the data layer), Spring provides specialized stereotype annotations for common application tiers.

#### A. `@Service`

  * **Purpose:** Marks a class that holds **business logic**. These classes typically sit between the web/controller layer and the data/repository layer.
  * **Location:** Service/Business layer.
  * **Technical Detail:** It is semantically equivalent to `@Component`, but it makes the code's intent clearer.

#### B. `@Repository`

  * **Purpose:** Marks a class that deals with **data access** or persistence operations (e.g., CRUD operations on a database).
  * **Location:** Persistence/Data Access Object (DAO) layer.
  * **Key Advantage:** It automatically enables Spring's **Persistence Exception Translation** feature, allowing checked, vendor-specific exceptions (like JDBC exceptions) to be translated into Spring's unified hierarchy of runtime `DataAccessException`s.

#### C. `@Controller`

  * **Purpose:** Marks a class that serves as a **controller** in the Spring MVC architecture. It handles incoming web requests, processes the input, and returns a view or data.
  * **Location:** Web/Presentation layer.
  * **Key Feature:** It is meta-annotated with `@Component` and is scanned by Spring, but it also enables specific web-handling features.

#### Code Example: Layered Application Structure

**`src/main/java/com/example/demo/controller/OrderController.java`**

```java
package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import com.example.demo.service.OrderService;

// Handles web requests
@Controller 
public class OrderController {

    private final OrderService orderService;

    // Dependency Injection of the Service bean
    @Autowired
    public OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    public void handleRequest(int orderId) {
        System.out.println("Controller received request for order ID: " + orderId);
        String status = orderService.checkOrderStatus(orderId);
        System.out.println("Order status: " + status);
    }
}
```

**`src/main/java/com/example/demo/service/OrderService.java`**

```java
package com.example.demo.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.example.demo.repository.OrderRepository;

// Holds business logic
@Service 
public class OrderService {

    private final OrderRepository orderRepository;

    @Autowired
    public OrderService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    public String checkOrderStatus(int orderId) {
        // Complex business logic could go here (e.g., calculations, validation)
        boolean exists = orderRepository.doesOrderExist(orderId);
        return exists ? "Processing" : "Not Found";
    }
}
```

**`src/main/java/com/example/demo/repository/OrderRepository.java`**

```java
package com.example.demo.repository;

import org.springframework.stereotype.Repository;

// Handles database access
@Repository 
public class OrderRepository {
    
    // Simulate database interaction
    public boolean doesOrderExist(int id) {
        System.out.println("Repository checking database for ID: " + id);
        return id % 2 == 0; // Simple logic: even IDs exist
    }
}
```

-----

### 3\. Combining Component Scanning and Autowiring

To make the beans defined above function together, we need two steps:

1.  Enable component scanning in the configuration.
2.  Use `@Autowired` in the components (as shown above) to inject dependencies.

#### Final Configuration and Execution

**`src/main/java/com/example/demo/config/AppConfig.java`**

```java
package com.example.demo.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
// Tell Spring to scan the base package of our components (controller, service, repository)
@ComponentScan("com.example.demo") 
public class AppConfig {
    // No explicit @Bean methods needed for the components, 
    // Spring finds them automatically!
}
```

**`src/main/java/com/example/demo/MainApplication.java`**

```java
package com.example.demo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import com.example.demo.config.AppConfig;
import com.example.demo.controller.OrderController;

public class MainApplication {
    public static void main(String[] args) {
        // Load the Java Configuration class
        ApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);

        // Get the top-level bean (Controller)
        OrderController controller = context.getBean(OrderController.class);

        // Execute the flow
        System.out.println("\n--- Testing Order ID 4 (Exists) ---");
        controller.handleRequest(4);

        System.out.println("\n--- Testing Order ID 5 (Doesn't Exist) ---");
        controller.handleRequest(5);
    }
}
```

**Output:**

```
--- Testing Order ID 4 (Exists) ---
Controller received request for order ID: 4
Repository checking database for ID: 4
Order status: Processing

--- Testing Order ID 5 (Doesn't Exist) ---
Controller received request for order ID: 5
Repository checking database for ID: 5
Order status: Not Found
```

This demonstrates how stereotype annotations, combined with `@ComponentScan` and `@Autowired`, allow Spring to automatically manage and wire the components in an application.

-----
