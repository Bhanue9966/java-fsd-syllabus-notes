# ⚙️ Spring Core and Boot

## 2\. Autowiring

### 1\. What is Autowiring?

**Autowiring** is the process by which the Spring IoC container automatically injects dependencies into a bean without the developer explicitly telling the container which bean to inject. It eliminates the need for manual configuration.

The `@Autowired` annotation is the primary mechanism for triggering autowiring in Spring.

### 2\. Autowiring Strategies

When the container sees an `@Autowired` annotation, it attempts to find a matching bean in the following order:

#### A. Autowiring by Type (Primary Method)

  * **Mechanism:** Spring searches the container for a bean whose data type (class or interface) matches the type of the injection target (field, constructor parameter, or setter parameter).
  * **Result:** If exactly one bean of that type is found, it is injected successfully.
  * **Problem:** If **two or more** beans of the same type are found (a non-unique dependency), Spring throws a `NoUniqueBeanDefinitionException`.

#### B. Autowiring by Name (Fallback/Explicit)

If the **by Type** method fails due to multiple matches, Spring uses the target field name as a unique identifier (Bean Name) to look up the dependency.

  * **Mechanism:** Spring looks for a bean whose name matches the field name (or setter parameter name).
  * **Example:** If the field is named `apple`, Spring looks for a bean named `apple`.

#### C. Using `@Qualifier` (The Solution to Ambiguity)

When Autowiring by Type results in multiple candidates, `@Qualifier` is used to explicitly specify which bean should be injected, resolving the ambiguity.

  * **Mechanism:** `@Qualifier` is used alongside `@Autowired` and takes the exact name of the desired bean as an argument.
  * **Syntax:**
    ```java
    @Autowired
    @Qualifier("theSpecificBeanName")
    private InterfaceType dependency;
    ```

### 3\. Demonstration Summary

The code below simulates a scenario where an `Alien` can use different types of `Processor` (e.g., `Intel` or `AMD`).

1.  We define an `Processor` interface and two concrete implementations (`Intel` and `AMD`).
2.  We demonstrate the need for `@Qualifier` because simply using `@Autowired` on the `Processor` field would result in an error (ambiguity).
3.  We use `@Qualifier` to tell Spring to specifically inject the `Intel` bean.

-----

Here are the Java files demonstrating Autowiring and `@Qualifier`:

```java
package com.telusko;

/**
 * The Dependency Interface
 */
public interface Processor {
    void process();
}
```

```java
package com.telusko;

import org.springframework.stereotype.Component;

/**
 * A concrete implementation of the Processor interface.
 * Named "intelProcessor" by default (due to class name capitalization).
 */
@Component
public class IntelProcessor implements Processor {

    @Override
    public void process() {
        System.out.println("Intel Processor: High-speed parallel computation running.");
    }
}
```

```java
package com.telusko;

import org.springframework.stereotype.Component;

/**
 * A second concrete implementation of the Processor interface.
 * Named "AMDProcessor" by default.
 */
@Component("amd") // Explicitly named "amd" for clarity
public class AMDProcessor implements Processor {

    @Override
    public void process() {
        System.out.println("AMD Processor: Efficient task processing enabled.");
    }
}
```