# ‚öôÔ∏è 6. Spring Core and Boot

## 07-java-config-annotations.md

### ‚òï Java-based Configuration (Annotation Config)

Instead of using XML files (`.xml`) to define Spring beans and their dependencies, we can use Java classes and annotations. This approach is often cleaner, type-safe, and allows for more flexible configuration logic.

#### Key Annotations

| Annotation | Location | Purpose |
| :--- | :--- | :--- |
| `@Configuration` | Class | Marks a class as a source of bean definitions. It's often used in conjunction with `@Bean`. |
| `@Bean` | Method | Marks a method that instantiates, configures, and initializes a new object to be managed by the Spring IoC container. |
| `@ComponentScan` | Class | Tells Spring where to look for other Spring components (like those annotated with `@Component`, `@Service`, `@Repository`, etc.). |

-----

### 1\. Creating a Configuration Class (`@Configuration` and `@Bean`)

We define a configuration class that replaces the need for an XML configuration file.

#### üìù Step 1: Define a Simple Service Class

Let's use a simple service class that we want to manage as a Spring bean.

**`src/main/java/com/example/config/MyService.java`**

```java
package com.example.config;

public class MyService {
    private String message;

    public MyService(String message) {
        this.message = message;
    }

    public void execute() {
        System.out.println("MyService executed: " + message);
    }
}
```

#### üìù Step 2: Create the Java Configuration Class

We use `@Configuration` on the class and `@Bean` on methods to define and configure the beans. The method name becomes the bean ID (unless explicitly specified in `@Bean("customId")`).

**`src/main/java/com/example/config/AppConfig.java`**

```java
package com.example.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    // The method name 'myServiceBean' will be the bean ID/name
    @Bean
    public MyService myServiceBean() {
        // This method creates and configures the MyService object
        return new MyService("Hello from Java Config!");
    }

    // Example of another bean definition with dependency injection (constructor injection)
    @Bean
    public AnotherService anotherService() {
        // The bean is created and injected with the 'myServiceBean' dependency
        // Calling myServiceBean() here simply retrieves the singleton instance from the container
        return new AnotherService(myServiceBean());
    }
}
```

#### üìù Step 3: Define the Dependent Class (for DI example)

**`src/main/java/com/example/config/AnotherService.java`**

```java
package com.example.config;

public class AnotherService {
    private MyService dependency;

    public AnotherService(MyService dependency) {
        this.dependency = dependency;
    }

    public void run() {
        System.out.println("AnotherService is running...");
        dependency.execute();
    }
}
```

#### üìù Step 4: Load the Configuration and Run

We use `AnnotationConfigApplicationContext` to load a Java configuration class, replacing the `ClassPathXmlApplicationContext`.

**`src/main/java/com/example/config/MainApplication.java`**

```java
package com.example.config;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MainApplication {
    public static void main(String[] args) {
        // 1. Create a container, providing the Java Config class
        ApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);

        // 2. Retrieve the beans
        MyService myService = context.getBean("myServiceBean", MyService.class);
        AnotherService anotherService = context.getBean(AnotherService.class); 
        // We can also retrieve by type if only one bean of that type exists

        // 3. Use the beans
        myService.execute();
        anotherService.run();

        // (AnnotationConfigApplicationContext can be closed using ((AnnotationConfigApplicationContext) context).close();)
    }
}
```

**Output:**

```
MyService executed: Hello from Java Config!
AnotherService is running...
MyService executed: Hello from Java Config!
```

-----

### 2\. Dependency Injection using `@Bean`

When a `@Bean` method takes an argument, Spring will automatically attempt to wire an existing bean of that argument's type from the container.

#### Example: Injecting Primitive/Literal Values

You can use the `@Value` annotation along with a property source (like a properties file) to inject simple values.

#### üìù Step 1: Create a Property File

**`src/main/resources/application.properties`**

```properties
app.service.name=Configuration Manager
app.service.port=8080
```

#### üìù Step 2: Update Configuration Class

We use `@PropertySource` to load the properties file and `@Value` to inject the property values.

**`src/main/java/com/example/config/AppConfig.java`**

```java
package com.example.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource("classpath:application.properties") // Load the properties file
public class AppConfig {

    // Inject value from application.properties
    @Value("${app.service.name}")
    private String serviceName;
    
    // Inject another property
    @Value("${app.service.port}")
    private int servicePort;

    @Bean
    public MyService myServiceBean() {
        // Use the injected values to configure the bean
        return new MyService(serviceName + " running on port: " + servicePort);
    }
    
    // ... other beans
}
```

-----

### 3\. Component Scanning (`@ComponentScan`)

For classes that are not part of the configuration itself (e.g., controllers, services, repositories), Spring offers a feature called **component scanning**. This allows Spring to automatically detect and register beans marked with stereotype annotations (like `@Component`).

If we wanted to use component scanning in our Java configuration, we'd add the `@ComponentScan` annotation:

**`src/main/java/com/example/config/AppConfig.java`**

```java
package com.example.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.example.components") // Scan this package for components
public class AppConfig {
    // ... @Bean methods can still be here for configuring 3rd party libraries 
    // or complex beans that can't be auto-scanned.
}
```

  * **Note:** If no package is specified in `@ComponentScan`, it scans the package of the configuration class itself and all sub-packages.

-----
