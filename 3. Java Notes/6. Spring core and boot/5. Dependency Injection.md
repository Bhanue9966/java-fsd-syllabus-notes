# ⚙️ Spring Core and Boot

## 5\. Dependency Injection Methods

Dependency Injection (DI) allows us to supply dependencies (collaborating objects) to a bean instead of having the bean create them itself. Spring provides three primary ways to achieve this, all using the `@Autowired` annotation.

### 1\. Field Injection (Using `@Autowired` on the field)

This is the simplest and most common form of DI, but often discouraged in modern practice.

| Feature | Description |
| :--- | :--- |
| **Mechanism** | Spring injects the dependency directly into the private field using Java reflection. |
| **Simplicity** | Requires minimal code (just the field declaration and `@Autowired`). |
| **Cons** | **No Immutability:** Cannot use `final` fields. |
| **Cons** | **Testability:** Difficult to unit test without the Spring container. |
| **Cons** | **Coupling:** Makes it easy to introduce too many dependencies (hiding complexity). |

```java
public class MyService {
    @Autowired
    private UserRepository repo; // Field Injection
}
```

### 2\. Setter Injection (Using `@Autowired` on the Setter Method)

Dependencies are supplied via the bean's public setter methods.

| Feature | Description |
| :--- | :--- |
| **Mechanism** | Spring calls the setter method (`setXyz(dependency)`) to inject the object. |
| **Mutability** | Allows the dependency to be changed/updated later (mutable state). |
| **Use Case** | Recommended for **optional** dependencies, as the setter can be called multiple times. |
| **Cons** | **No Immutability:** Cannot enforce immutability of the dependency. |

```java
public class MyService {
    private UserRepository repo;

    @Autowired
    public void setRepo(UserRepository repo) { // Setter Injection
        this.repo = repo;
    }
}
```

### 3\. Constructor Injection (Using `@Autowired` on the Constructor)

Dependencies are passed as arguments to the constructor. This is the **recommended** approach for injecting mandatory dependencies.

| Feature | Description |
| :--- | :--- |
| **Mechanism** | Spring resolves all constructor arguments and passes them to the constructor when creating the bean. |
| **Immutability** | **Key Benefit:** Allows the dependent field to be declared as `final`, ensuring it's initialized only once and never changed. |
| **Testability** | Highly testable: dependencies can be easily mocked by calling the constructor directly in unit tests. |
| **Note** | If a class has only one constructor, the `@Autowired` annotation is **optional** in Spring Boot 2.x and later, but still good practice to include. |

```java
public class MyService {
    private final UserRepository repo; // Recommended: declare as final

    @Autowired
    public MyService(UserRepository repo) { // Constructor Injection
        this.repo = repo;
    }
}
```

-----

Here are the Java files demonstrating all three injection methods:

```java
package com.telusko;

/**
 * Interface representing a dependency.
 */
public interface Engine {
    String start();
}
```

```java
package com.telusko;

import org.springframework.stereotype.Component;

/**
 * Implementation for Field and Setter Injection Demos.
 */
@Component("v6Engine")
public class V6Engine implements Engine {

    @Override
    public String start() {
        return "V6 Engine started. (Medium power)";
    }
}
```

```java
package com.telusko;

import org.springframework.stereotype.Component;

/**
 * Implementation for Constructor Injection Demo (used with @Qualifier).
 */
@Component("v8Engine")
public class V8Engine implements Engine {

    @Override
    public String start() {
        return "V8 Engine started. (High performance!)";
    }
}
```

```java
package com.telusko;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * Demonstrates the simplest form: Field Injection.
 */
@Component
public class FieldInjectionDemo {
    
    // 1. Field Injection
    // Spring uses reflection to inject the 'v6Engine' bean here.
    @Autowired 
    private Engine engine;

    public void run() {
        System.out.println("--- Field Injection Demo ---");
        System.out.println("Running with: " + engine.start());
    }
}
```

```java
package com.telusko;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * Demonstrates injection via a public setter method.
 */
@Component
public class SetterInjectionDemo {
    
    private Engine engine;

    // 2. Setter Injection
    // Spring calls this method after the bean is constructed.
    @Autowired
    public void setEngine(Engine engine) {
        System.out.println("Setter Injection: Dependency set.");
        this.engine = engine;
    }

    public void run() {
        System.out.println("--- Setter Injection Demo ---");
        System.out.println("Running with: " + engine.start());
    }
}
```

```java
package com.telusko;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

/**
 * Demonstrates the recommended form: Constructor Injection (using @Qualifier for clarity).
 */
@Component
public class ConstructorInjectionDemo {
    
    // Recommended practice: make the field final to ensure immutability
    private final Engine engine;

    // 3. Constructor Injection
    // Spring finds this constructor, resolves the 'Engine' dependency, 
    // and passes the V8Engine instance to it.
    @Autowired
    @Qualifier("v8Engine") // Explicitly resolving the dependency to the V8 implementation
    public ConstructorInjectionDemo(Engine engine) {
        this.engine = engine;
        System.out.println("Constructor Injection: Dependency initialized.");
    }

    public void run() {
        System.out.println("--- Constructor Injection Demo ---");
        System.out.println("Running with: " + engine.start());
    }
}
```

We have successfully covered the three major types of Dependency Injection: Field, Setter, and Constructor, highlighting the best practice of using Constructor Injection for mandatory dependencies.
