# ‚öôÔ∏è 6. Spring Core and Boot

## 10-springboot-layers.md

### üèóÔ∏è Spring Boot Application Layers

A professional Spring Boot application typically follows a layered architecture, most commonly the **Model-View-Controller (MVC)** pattern extended with Service and Repository layers. This separation of concerns (SoC) makes the application scalable, maintainable, and testable.

The primary layers are:

1.  **Controller Layer (Web/API)**
2.  **Service Layer (Business Logic)**
3.  **Repository Layer (Data Access)**

-----

### 1\. The Controller Layer (Web/API)

This is the outermost layer responsible for handling incoming HTTP requests and returning HTTP responses.

  * **Role:** Handles routing, request validation, marshaling/unmarshaling (converting HTTP request body to Java objects and vice-versa).
  * **Key Annotations:**
      * `@RestController`: Marks a class to handle web requests and automatically serializes the return value into the response body (e.g., JSON).
      * `@RequestMapping`, `@GetMapping`, `@PostMapping`, etc.: Map specific HTTP methods and URLs to controller methods.
  * **Interaction:** Calls methods in the **Service Layer** but should never directly call the Repository Layer.
  * **Data Models:** Typically works with **DTOs (Data Transfer Objects)** or **Request/Response objects**, not the core entity objects.

#### Code Example

```java
package com.example.app.controller;

import com.example.app.service.ProductService;
import com.example.app.model.Product;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    @Autowired
    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    // Handles GET /api/products
    @GetMapping
    public List<Product> getAllProducts() {
        // Calls the Service layer for business processing
        return productService.findAll(); 
    }

    // Handles POST /api/products
    @PostMapping
    public Product createProduct(@RequestBody Product newProduct) {
        // Validation and error handling is typically done here or in the Service layer
        return productService.save(newProduct);
    }
}
```

-----

### 2\. The Service Layer (Business Logic)

This is the heart of the application, containing all the core business rules and transaction boundaries.

  * **Role:** Orchestrates the flow of data, performs complex calculations, enforces business rules, and manages transactions.
  * **Key Annotation:** `@Service`
  * **Interaction:** Calls methods in one or more **Repository Layers**. It can also call other Service Layers, though care must be taken to avoid circular dependencies.
  * **Data Models:** Works with the core **Entity Models** of the application.

#### Code Example

```java
package com.example.app.service;

import com.example.app.repository.ProductRepository;
import com.example.app.model.Product;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class ProductService {

    private final ProductRepository productRepository;

    @Autowired
    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    // Business rule: Ensure product names are unique before saving
    public Product save(Product product) {
        if (productRepository.existsByName(product.getName())) {
            throw new IllegalArgumentException("Product name already exists.");
        }
        // Calls the Repository layer to perform the persistence operation
        return productRepository.save(product); 
    }

    public List<Product> findAll() {
        return productRepository.findAll();
    }
}
```

-----

### 3\. The Repository Layer (Data Access)

This layer's sole responsibility is to communicate with the persistence store (database, file system, external APIs).

  * **Role:** Contains the logic for fetching, storing, updating, and deleting data. It translates between the application's entity models and the database's data structure (SQL, NoSQL commands).
  * **Key Annotation:** `@Repository`
  * **Interaction:** Communicates directly with the database via technologies like JDBC, JPA, or MongoDB drivers.
  * **Abstraction:** With Spring Data JPA, this layer often involves simply defining an interface that extends `JpaRepository`, reducing boilerplate code to almost zero.

#### Code Example (Using Spring Data JPA)

```java
package com.example.app.repository;

import com.example.app.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// Spring Data JPA automatically provides CRUD methods (save, findAll, findById, delete, etc.)
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Custom query method derived automatically by Spring Data based on method name
    boolean existsByName(String name);
}
```

-----

### 4\. The Model/Entity Layer

While not a functional layer in the processing flow, the Model/Entity layer is critical.

  * **Role:** Represents the data structure. **Entities** represent objects stored in the database. **DTOs** (Data Transfer Objects) are used for communication between the Controller and external clients.
  * **Key Annotations:** `@Entity` (for JPA entities), `@Data` (from Lombok, often used for DTOs).

#### Code Example (JPA Entity)

```java
package com.example.app.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;

@Entity
public class Product {
    
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    private double price;

    // Standard Getters and Setters omitted for brevity
}
```

-----

### Summary of Data Flow

1.  **Client $\rightarrow$ Controller:** HTTP Request received.
2.  **Controller $\rightarrow$ Service:** Controller calls the Service method, passing input data.
3.  **Service $\rightarrow$ Repository:** Service applies business logic, then calls the Repository to perform persistence operations.
4.  **Repository $\rightarrow$ Database:** Executes database query (e.g., SQL).
5.  **Database $\rightarrow$ Repository $\rightarrow$ Service $\rightarrow$ Controller $\rightarrow$ Client:** Data returns up the stack, is potentially mapped/transformed in the Controller, and finally sent back as an HTTP Response.

This layered approach is the standard, production-ready structure for all Spring Boot applications.

-----
