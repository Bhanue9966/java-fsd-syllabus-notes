# ðŸ’¡ Object-Oriented Programming (OOP)

## 10\. Polymorphism and Dynamic Method Dispatch (DMD)

### 1\. Polymorphism: The Concept ðŸŽ­

**Polymorphism** is the fourth major pillar of OOP, and its name literally means "many forms" (from Greek: *poly* = many, *morph* = forms).

In Java, polymorphism allows an entity (like a method or an object reference) to exhibit **different behaviors** in different contexts.

#### Two Types of Polymorphism:

1.  **Compile-Time Polymorphism (Static Polymorphism):** Achieved through **Method Overloading**. The compiler decides which overloaded method to call based on the arguments' type and count.
2.  **Runtime Polymorphism (Dynamic Polymorphism):** Achieved through **Method Overriding**. The JVM decides which overridden method to call based on the actual type of the object being referenced, which can only be determined at runtime.

### 2\. Runtime Polymorphism and Upcasting

Runtime polymorphism relies on two concepts: **Inheritance** and **Upcasting**.

  * **Upcasting:** When you create a reference variable of the **Superclass** type and point it to an **Object** of the **Subclass** type. This is always safe and automatic (implicit).

    $$\text{SuperClass Reference} = \text{new SubClass()};$$

    ```java
    // Parent class reference (Animal) points to a Child object (Dog)
    Animal myAnimal = new Dog(); // This is Upcasting

    // Parent class reference (Vehicle) points to a Child object (Car)
    Vehicle myVehicle = new Car(); 
    ```

### 3\. Dynamic Method Dispatch (DMD) âš¡

**Dynamic Method Dispatch (DMD)** is the mechanism used by the JVM to implement Runtime Polymorphism. It ensures that the **overridden method of the subclass** is always called, even when the object is referenced by a variable of the superclass type.

#### The DMD Process:

1.  **Compilation:** The compiler only checks if the method exists in the **Superclass** type (the reference type).
2.  **Runtime:** When the method is actually called (`myAnimal.makeSound()`), the **JVM** looks at the **actual object type** (the `new Dog()`) residing on the Heap.
3.  **Dispatch:** The JVM dynamically binds the method call to the implementation provided by the **Subclass** (`Dog`), overriding the Superclass's version.

#### Example Demonstrating DMD

```java
class Shape {
    void draw() {
        System.out.println("Drawing a generic shape.");
    }
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a circle."); // Overridden method
    }
}

public class DMD_Demo {
    public static void main(String[] args) {
        // Upcasting: Reference type is Shape, Object type is Circle
        Shape s = new Circle(); 
        
        // DMD in action: The compiler knows 'draw()' exists in Shape, 
        // but the JVM calls the Circle's version at runtime.
        s.draw(); // Output: Drawing a circle.
    }
}
```

  * **Key Takeaway:** With DMD, the method that runs is always determined by the **actual object type** (the object on the Heap), not the reference variable type (the variable on the Stack).

