# ðŸ’¡ Object-Oriented Programming (OOP)

## 15\. The `Object` Class and Its Core Methods

The **`Object` class** (defined in the `java.lang` package) is the superclass of every class in Java. Whether you explicitly extend it or not, every class you create directly or indirectly inherits from `Object`.

  * **Implication:** Every single object in Java inherits and contains the methods defined in the `Object` class.

### 1\. Key Methods Inherited by All Objects

The `Object` class defines several fundamental methods, but the following are the most frequently used and often overridden:

#### A. `toString()`

This method returns a **String representation** of the object.

  * **Default Implementation:** The default implementation returns a string consisting of the object's class name, the `@` symbol, and the object's hash code (in hexadecimal format).
      * *Example Default Output:* `com.app.model.Employee@5e9f23b`
  * **Purpose of Overriding:** When printing or logging an object, this default output is usually useless. You should **override** `toString()` to return meaningful data that describes the object's state (e.g., all its field values).

<!-- end list -->

```java
public class Person {
    String name = "Alice";
    int age = 30;

    @Override
    public String toString() {
        // Provide a useful, human-readable description
        return "Person [name=" + name + ", age=" + age + "]";
    }
}
// When System.out.println(new Person()) is called, it implicitly calls toString()
```

#### B. `equals(Object obj)`

This method is used to compare two objects for **equality**.

  * **Default Implementation:** The default implementation of `equals()` performs an **identity comparison** (the same as `==`), checking if the two object references point to the **exact same object** in memory.
  * **Purpose of Overriding:** In most practical scenarios, you want to compare objects based on their **content** (their data fields), not their memory address. If you need two objects with identical data to be considered "equal," you **must override** this method.

<!-- end list -->

```java
// Check if two Employee objects have the same ID
public class Employee {
    int id;
    
    // ... constructor and other methods
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // Identity check (same object)
        if (obj == null || getClass() != obj.getClass()) return false; // Type check
        
        Employee other = (Employee) obj; // Downcast
        return id == other.id; // Content check
    }
}
```

#### C. `hashCode()`

This method returns an **integer hash code** for the object.

  * **The Contract:** The fundamental contract between `equals()` and `hashCode()` is: **If two objects are equal according to the `equals(Object)` method, then calling the `hashCode` method on each of the two objects must produce the same integer result.**
  * **Purpose of Overriding:** If you override `equals()`, you **must** also override `hashCode()`. This is essential for objects used in hash-based collections like `HashMap`, `HashSet`, and `Hashtable`. If the hash codes don't match for equal objects, these collections won't be able to find the objects correctly.

-----

### 2\. Identity (`==`) vs. Equality (`equals()`)

It's critical to understand the difference between these two types of comparison:

| Comparison | Operator/Method | What It Checks | Context |
| :--- | :--- | :--- | :--- |
| **Identity** | **`==`** | Checks if two references point to the **same object** in the Heap memory. | Default for primitives and objects. |
| **Equality** | **`equals()`** | Checks if two objects are **logically equivalent** (i.e., contain the same data). | Used when `equals()` is overridden. |

```java
String s1 = new String("hello");
String s2 = new String("hello");

System.out.println(s1 == s2);      // Output: false (Different objects in memory)
System.out.println(s1.equals(s2)); // Output: true (Same content/value)
```

