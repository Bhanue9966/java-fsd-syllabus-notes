# ðŸ’¡ Object-Oriented Programming (OOP)

## 13\. Interfaces

An **Interface** is a blueprint of a class. It is a completely abstract type used to define a **contract** of behavior that implementing classes must adhere to.

### 1\. The Principle of Interfaces ðŸ“œ

  * **Keyword:** Interfaces are declared using the `interface` keyword.
  * **Purpose:** To achieve **total abstraction** and support **multiple inheritance of behavior** (solving the Diamond Problem).
  * **Instantiation Rule:** You **cannot** create objects of an interface.
  * **Implementation:** A class uses the **`implements`** keyword to adopt an interface.

### 2\. Interface Members (Before Java 8)

Historically, interfaces were very restrictive. All members were implicitly defined with strict modifiers:

| Member Type | Implicit Modifiers | Behavior |
| :--- | :--- | :--- |
| **Methods** | `public abstract` | They have no body; implementing classes **must** provide the body. |
| **Variables** | `public static final` | They are constants; they must be initialized at declaration. |

### 3\. Java 8 and Beyond (Evolved Interfaces)

Java 8 introduced new features to enhance interfaces without breaking the principle of contracts:

#### A. Default Methods

These methods allow you to add **concrete method implementations** directly into an interface.

  * **Purpose:** To safely add new methods to an existing interface without forcing all implementing classes (which might be in different libraries) to update and implement the new method immediately.
  * **Keyword:** Declared with the **`default`** keyword.

<!-- end list -->

```java
public interface LoggingService {
    // Abstract method (must be implemented)
    void logMessage(String message);
    
    // Default method (provides a default implementation)
    default void logTime() {
        System.out.println("Time: " + System.currentTimeMillis());
    }
}
```

#### B. Static Methods

Interfaces can also have `static` methods.

  * **Purpose:** To provide utility methods related to the interface that can be called directly on the interface itself (e.g., `List.of()`) without requiring an implementing object.

### 4\. Interface Inheritance (Extending)

An interface can extend **one or more** other interfaces. This allows you to combine contracts.

  * **Keyword:** Interfaces use **`extends`** to inherit from other interfaces.

<!-- end list -->

```java
// Combining contracts
public interface AdvancedCalculator extends BasicCalculator, ScientificCalculator {
    // ... adds more methods
}
```

### 5\. Abstract Class vs. Interface (Recap)

| Feature | Abstract Class | Interface |
| :--- | :--- | :--- |
| **Multiple Parents** | **Single** inheritance (can only `extend` one class). | **Multiple** inheritance (can `implement` many interfaces). |
| **Constructors** | Can have constructors. | Cannot have constructors. |
| **Methods (Concrete)** | Can have regular methods (`public`, `private`, etc.). | Can only have `default` or `static` methods (Java 8+). |
| **Variables** | Can have any variable type (`private`, `int`, etc.). | Variables are implicitly `public static final`. |


## 6\. ðŸ› ï¸ Types of Interfaces

Interfaces in Java can be broadly categorized based on the purpose they serve.

### A. Regular Interface (Standard Contract)

This is the standard interface you've already described, which defines a **set of abstract methods** (the contract) that a class must implement.

### B. Marker Interface (Tagging)

A **Marker Interface** is a special type of interface that contains **no methods** or **fields**.

  * **Purpose:** It serves to **"tag"** or **"mark"** a class, indicating that the class has a special property or capability. The Java Virtual Machine (JVM) or compiler can then use this tag to perform specific operations on the marked class.
  * **Examples in Java:**
      * **`java.io.Serializable`**: Marking a class with this interface tells the JVM that objects of this class can be written to a stream (serialized).
      * **`java.lang.Cloneable`**: Marking a class with this interface tells the JVM that the `clone()` method is safe to call to create a field-by-field copy of the object.

### C. Functional Interface (Lambda Support)

A **Functional Interface** is an interface that contains **exactly one abstract method**.

  * **Purpose:** Its primary role is to act as a target type for **Lambda Expressions** and **Method References**, which were introduced in Java 8. This is the foundation for functional programming in Java.
  * **Annotation:** They are often annotated with the **`@FunctionalInterface`** annotation. This annotation is optional but is a best practice, as it causes the compiler to check that the interface indeed only has one abstract method.
  * **Rules for Abstract Methods:**
      * It must have **exactly one** abstract method.
      * It **can** have any number of `default` or `static` methods (as they have a body and are not abstract).
      * It **can** override methods from the `java.lang.Object` class (like `equals`, `toString`) without affecting the functional interface status, as these are *implicitly* implemented by every class.

#### **Example of a Functional Interface**

```java
// The compiler will enforce the 'single abstract method' rule here
@FunctionalInterface
public interface Validator {
    // The single abstract method
    boolean validate(String input); 
    
    // A default method is allowed
    default void printInfo() {
        System.out.println("Validator in use.");
    }
}
```

#### **Using the Functional Interface with a Lambda**

A lambda expression provides the implementation for the single abstract method:

```java
// The lambda expression (s -> s.length() > 5) implements the validate(String) method.
Validator lengthChecker = (s) -> s.length() > 5;

System.out.println("Is 'hello' valid? " + lengthChecker.validate("hello")); 
// Output: Is 'hello' valid? false

System.out.println("Is 'universe' valid? " + lengthChecker.validate("universe"));
// Output: Is 'universe' valid? true
```

#### **Predefined Functional Interfaces**

Java provides several built-in functional interfaces in the `java.util.function` package, including:

  * **`Predicate<T>`:** Takes one argument and returns a boolean (e.g., used for filtering).
  * **`Function<T, R>`:** Takes one argument of type $T$ and returns a result of type $R$ (e.g., used for mapping/transforming).
  * **`Consumer<T>`:** Takes one argument of type $T$ and returns no result (`void`) (e.g., used for performing an action on an object).
  * **`Supplier<T>`:** Takes no arguments and returns a result of type $T$ (e.g., used for factory methods or lazy initialization).
