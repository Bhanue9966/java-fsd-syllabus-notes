# ðŸ’¡ Object-Oriented Programming (OOP)

## 9\. Method Overriding (Runtime Polymorphism)

**Method Overriding** is the ability of a **subclass** to provide a specific implementation for a method that is already defined in its **superclass**.

This is crucial for achieving **Runtime Polymorphism** (or Dynamic Polymorphism), where the decision of which method to execute is made at runtime, not compile time.

### 1\. The Principle of Overriding

  * **When it Occurs:** It happens when the method in the subclass has the **exact same signature** (same name, same number and type of parameters, and same return type) as a method in its superclass.
  * **Purpose:** To customize or specialize the inherited method for the specific needs of the subclass.

#### Example

```java
// Superclass
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound.");
    }
}

// Subclass
class Cat extends Animal {
    // Method Overriding: Same signature as in Animal
    @Override // Annotation: Good practice to indicate overriding
    public void makeSound() {
        System.out.println("Cat purrs."); // New, specific implementation
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myCat = new Cat(); 
        // Calls Cat's version at runtime
        myCat.makeSound(); // Output: Cat purrs.
    }
}
```

### 2\. Rules for Method Overriding

To be considered a valid override, a method must follow these rules:

1.  **Same Signature:** The overridden method must have the exact same **name**, **parameter list**, and **return type** (or a covariant return type, which is a subtype of the superclass's return type).
2.  **Access Modifier:** The access modifier of the overriding method **cannot be more restrictive** than the overridden method. You can widen the access (e.g., from `protected` to `public`), but you cannot restrict it (e.g., from `public` to `private`).
3.  **Exceptions:** The overriding method cannot throw new or broader checked exceptions than the overridden method.
4.  **Keywords:** Methods declared as **`final`** or **`static`** **cannot be overridden**.

### 3\. @Override Annotation

While optional, it is highly recommended to use the **`@Override`** annotation above any method you intend to override.

  * **Benefit:** It tells the compiler to check if the method is actually overriding a superclass method. If you make a typo in the method signature, the compiler will immediately flag an error, preventing subtle bugs.

### 4\. Method Overloading vs. Method Overriding

These terms sound similar but are very different mechanisms of **Polymorphism**.

| Feature | Method Overloading | Method Overriding |
| :--- | :--- | :--- |
| **Concept** | Compile-Time (Static) Polymorphism | Runtime (Dynamic) Polymorphism |
| **Scope** | Happens within the **same class** (or inherited classes). | Happens between a **Superclass** and a **Subclass**. |
| **Signature** | Parameters **must** be different. | Signature **must** be the same. |
| **Return Type** | Can be the same or different. | Must be the same (or covariant). |
| **Purpose** | To define multiple ways to execute one logical action (e.g., `add`). | To provide a specialized implementation for an inherited action (e.g., `run()`). |

