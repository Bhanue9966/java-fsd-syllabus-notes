# ðŸ’¡ Object-Oriented Programming (OOP)

## 16\. Casting (Upcasting and Downcasting)

**Casting** in Java is the process of converting one type of object reference to another type. This is only possible when there is an **IS-A relationship** (inheritance) between the types.

### 1\. Upcasting (Widening)

**Upcasting** is the process of casting a **subclass** reference to a **superclass** reference.

  * **Process:** This is done **implicitly** (automatically) by the compiler because it is always safe. The subclass object is always a valid instance of the superclass.
  * **Result:** The reference variable can only access the **inherited members** (variables and methods) that are defined in the superclass. Any unique members of the subclass are hidden, though the object itself still retains them.

$$\text{SuperClass Reference} = \text{new SubClass()};$$

| Feature | Subclass to Superclass |
| :--- | :--- |
| **Safety** | Always Safe |
| **Mechanism** | Automatic (Implicit) |
| **Visibility** | Only Superclass methods are accessible (Dynamic Method Dispatch still applies for overridden methods). |

#### Example of Upcasting

```java
class Vehicle {
    void start() { System.out.println("Vehicle starting."); }
    void brake() { /* ... */ }
}

class Car extends Vehicle {
    void start() { System.out.println("Car starting."); } // Overridden
    void turn()  { System.out.println("Car turning."); }   // Car's unique method
}

// Upcasting: Car object is referenced by a Vehicle type
Vehicle v = new Car(); 

v.start(); // Output: Car starting. (DMD calls the overridden method)
v.brake(); // Output: (Works)
// v.turn(); // ERROR: The Vehicle reference cannot see the Car's unique turn() method
```

### 2\. Downcasting (Narrowing)

**Downcasting** is the process of casting a **superclass** reference back to a **subclass** reference.

  * **Process:** This must be done **explicitly** using the casting operator `(SubClass)`. It is **unsafe** because the superclass reference might not actually point to an object of the intended subclass.
  * **Result:** If successful, the reference variable can now access all members unique to the subclass.
  * **Risk:** If the object being referenced is **not** an instance of the target subclass, a **`ClassCastException`** is thrown at runtime.

$$\text{SubClass Reference} = (\text{SubClass}) \text{SuperClass Reference};$$

| Feature | Superclass to Subclass |
| :--- | :--- |
| **Safety** | Unsafe (Risk of `ClassCastException`) |
| **Mechanism** | Explicit (Requires `(SubClass)`) |
| **Visibility** | All Subclass methods are now accessible. |

#### Example of Downcasting

```java
// Continuing the previous example:
Vehicle v = new Car(); // Object is actually a Car (Upcast)

// Downcasting: v (Vehicle reference) is cast to a Car reference
Car c = (Car) v;

c.start(); // Works
c.turn();  // Works! Car's unique method is now accessible.

// UNSAFE Downcasting Example:
// Vehicle v2 = new Vehicle(); // Object is ONLY a Vehicle
// Car c2 = (Car) v2;          // RUNTIME ERROR: ClassCastException (A Vehicle is NOT a Car)
```

### 3\. The `instanceof` Operator

To avoid the runtime `ClassCastException` during downcasting, you should always verify the object's type first using the **`instanceof`** operator.

  * **Usage:** It checks if an object is an instance of a particular class or interface. It returns `true` or `false`.

<!-- end list -->

```java
Vehicle v3 = new Vehicle();

// Check before downcasting
if (v3 instanceof Car) {
    Car c3 = (Car) v3; // This will safely execute only if v3 is a Car
} else {
    System.out.println("Cannot cast: Object is not a Car.");
}
// Output: Cannot cast: Object is not a Car.
```
