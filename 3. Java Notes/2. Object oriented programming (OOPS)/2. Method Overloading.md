# ðŸ’¡ Object-Oriented Programming (OOP)

## 2\. Methods and Method Overloading

### 1\. Methods: Defining Behavior

A **Method** is a block of code within a class that performs a specific action or operation. It defines the **behavior** of an object.

  * Methods are necessary for objects to communicate, manipulate data, and execute logic.
  * Every method must be declared with a return type (or `void` if it returns nothing).

#### Method Structure (Syntax)

```java
// Access Modifier | Optional Specifier | Return Type | Method Name | (Parameters)
public             static             int           calculateArea (int length, int width) {
    // Method body
    int area = length * width;
    return area; // Must return a value matching the Return Type
}
```

| Component | Description |
| :--- | :--- |
| **Access Modifier** | Controls visibility (e.g., `public`, `private`, `protected`). |
| **Return Type** | The data type of the value the method sends back (`int`, `String`, `void`, etc.). |
| **Method Name** | Should be a verb in **camelCase** (e.g., `calculateArea`). |
| **Parameters** | The input variables the method accepts, defined inside the parentheses. |

### 2\. Method Overloading (Compile-Time Polymorphism)

**Method Overloading** is the ability for a class to have **multiple methods with the exact same name**, provided they have different **parameter lists**.

This allows you to write one conceptual function (e.g., `add`) that can handle different types or quantities of input data.

  * **Mechanism:** The Java Compiler determines which method to call based on the number and type of arguments passed. This is why it's also known as **Compile-Time Polymorphism** (or Static Polymorphism).

#### ðŸ“œ Rules for Method Overloading

To successfully overload a method, the parameter list **must** differ in at least one of these ways:

1.  **Number of parameters:** (e.g., `add(int a, int b)` vs. `add(int a, int b, int c)`)
2.  **Data type of parameters:** (e.g., `add(int a, int b)` vs. `add(double a, double b)`)
3.  **Order of parameters** (if types are different): (e.g., `print(int a, String s)` vs. `print(String s, int a)`)

> ðŸ›‘ **Crucial Note:** Changing only the **return type** or the **access modifier** is **NOT** sufficient for overloading. The parameter list must change.

#### Example of Overloading

```java
public class Calculator {
    
    // 1. Overload: Two integer parameters
    int add(int a, int b) {
        return a + b;
    }
    
    // 2. Overload: Three integer parameters (Different number)
    int add(int a, int b, int c) {
        System.out.println("Using 3-parameter overload.");
        return a + b + c;
    }
    
    // 3. Overload: Two double parameters (Different type)
    double add(double a, double b) {
        System.out.println("Using double overload.");
        return a + b;
    }
    
    // Main method to test
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        System.out.println(calc.add(10, 20));       // Calls #1 (int, int) -> 30
        System.out.println(calc.add(10, 20, 30));   // Calls #2 (int, int, int) -> 60
        System.out.println(calc.add(5.5, 4.5));     // Calls #3 (double, double) -> 10.0
    }
}
```
