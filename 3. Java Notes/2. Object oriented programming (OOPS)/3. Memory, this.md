# ðŸ’¡ Object-Oriented Programming (OOP)

## 3\. Stack and Heap Memory, and The `this` Keyword

Understanding where data lives is crucial for efficient programming, especially for managing objects.

### 1\. Stack and Heap Memory

When a Java program runs, the Java Virtual Machine (JVM) divides the memory into several areas, but the two main ones you interact with are the **Stack** and the **Heap**.

| Feature | Stack Memory | Heap Memory |
| :--- | :--- | :--- |
| **Primary Use** | Stores **local variables** and **references** to objects. | Stores **all objects** (instances of classes) and **instance variables**. |
| **Lifetime** | Short. Tied to the lifespan of the method/function call (a **Stack Frame**). | Longer. Lives until the object is no longer referenced by any part of the program, at which point it's cleaned up by the **Garbage Collector**. |
| **Allocation Speed** | Very Fast. | Comparatively Slower. |
| **Size** | Small and fixed. | Large, flexible, and dynamically allocated. |

#### How They Work Together

1.  When you call a method (e.g., `main()`), a new **Stack Frame** is pushed onto the Stack.
2.  Inside that method, **primitive variables** (like `int x = 10;`) and **object reference variables** (like `Dog myDog;`) are stored directly on the **Stack**.
3.  When you create an object (`myDog = new Dog();`), the actual `Dog` **object data** is stored on the **Heap**.
4.  The `myDog` variable on the Stack contains the **address** (reference) that points to the object on the Heap.

### 2\. The `this` Keyword

The **`this`** keyword is a special **reference variable** in Java that refers to the **current object** (the object whose method is currently being called).

It's primarily used to resolve ambiguity and to call constructors.

#### A. Resolving Ambiguity

The most common use is to differentiate between an **instance variable** (a field of the class) and a **local variable** or **method parameter** that has the same name.

```java
public class Employee {
    String name; // Instance variable
    
    // Parameter 'name' shadows the instance variable 'name'
    public Employee(String name) {
        // Use 'this.name' to refer to the instance variable
        this.name = name; 
        
        // If we didn't use 'this': name = name; 
        // This would just assign the parameter to itself, leaving the instance variable uninitialized.
    }
}
```

#### B. Calling Class Members

You can use `this` to explicitly call an instance method or access an instance variable of the current object. While optional most of the time, it improves clarity.

```java
public void displayDetails() {
    System.out.println("Employee Name: " + this.name);
    // this.calculateBonus(); // Calling a method on the current object
}
```

#### C. Calling Constructors (Constructor Chaining)

The `this()` call is used **inside one constructor** to explicitly invoke **another constructor** from the same class. This is called **Constructor Chaining** and helps avoid duplicating initialization code.

  * **Rule:** `this()` must be the **very first statement** in the constructor where it is used.

<!-- end list -->

```java
public class Box {
    int width;
    int height;
    
    // 1. Parameterized Constructor
    public Box(int width, int height) {
        this.width = width;
        this.height = height;
    }
    
    // 2. Default Constructor
    public Box() {
        // Calls the parameterized constructor (Constructor Chaining)
        this(10, 10); 
        System.out.println("Default box created.");
    }
}
```
