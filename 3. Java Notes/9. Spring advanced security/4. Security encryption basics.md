# ðŸ”’ 9. Spring Advanced Security

## 04-security-encryption-basics.md

### 1. Fundamentals of Application Security

The entire field of information security is often built upon three core concepts, collectively known as the **CIA Triad**.

#### The CIA Triad

1.  **Confidentiality:** Ensures that sensitive data is kept secret and is only accessed by authorized parties.
    * *Example:* Using **Encryption** (like TLS/SSL) to protect data both in transit and at rest.
2.  **Integrity:** Guarantees that data remains accurate, consistent, and unaltered during its entire lifecycle.
    * *Example:* Using **Hashing** or digital signatures to verify that a file hasn't been tampered with.
3.  **Availability:** Ensures that the authorized users can reliably access the system and data when needed.
    * *Example:* Using load balancing, backups, and redundancy.


---

### 2. Authentication vs. Authorization

These two terms are often confused but serve distinct purposes in Spring Security:

| Concept | Question Answered | Spring Security Role |
| :--- | :--- | :--- |
| **Authentication** | **"Who are you?"** (Verifying identity) | Determining the current **`Principal`** (User). |
| **Authorization** | **"What are you allowed to do?"** (Granting access) | Determining if the authenticated `Principal` has the necessary **`Role`** or **`Permission`** to access a resource (e.g., ADMIN role can delete, USER role can only read). |

* **Flow:** Authentication must always precede authorization. You must know *who* the user is before you can decide *what* they can do.

---

### 3. Password Security: Hashing and Salting

When dealing with user passwords, security best practices dictate that you **never store the plain-text password** in the database. Instead, you store a **one-way hash**.

#### A. Hashing (One-Way Encryption)

**Hashing** is a process that converts an input (the password) into a fixed-size, unique string of characters (the hash).

* **One-Way:** It is mathematically infeasible to reverse the process and get the original password from the hash.
* **Verification:** To check a login attempt, the system hashes the provided password and compares the new hash against the stored hash. If they match, the password is correct.

#### B. The Need for Salting

Simple hashing (e.g., using only SHA-256) is vulnerable to **Rainbow Table attacks** (pre-calculated tables of common password hashes). **Salting** solves this:

1.  A **Salt** is a unique, randomly generated string.
2.  The salt is added (concatenated) to the plain-text password *before* hashing.
3.  The resulting hash is stored along with the salt in the database.

* **Benefit:** Even if two users choose the same password ("password123"), their final hashes will be different because their unique salts are different. This defeats rainbow table attacks.



#### C. Spring's Standard: **BCrypt**

Spring Security strongly recommends and uses **BCrypt** as its default password hashing algorithm.

* **Adaptive Hashing:** BCrypt is designed to be slow and computationally intensive (by adjusting the *cost factor*), making brute-force guessing attacks exponentially harder as computing power increases. This intentional slowness is a feature, not a bug, making it suitable for password storage.

---

### 4. Encryption for Data (Symmetric vs. Asymmetric)

While hashing is for passwords, **Encryption** is for data that needs to be readable by authorized parties (e.g., securing communication).

| Type | Key Structure | Use Case |
| :--- | :--- | :--- |
| **Symmetric** | Uses **one single key** for both encryption and decryption. | Securing large amounts of data quickly (e.g., AES for database encryption). |
| **Asymmetric** | Uses a **key pair** (a public key for encryption and a private key for decryption). | Digital signatures, key exchange, and securing initial communication (e.g., RSA, TLS/SSL handshake). |

The next modules will leverage these concepts to build robust Spring Security configurations.
