# ðŸ”’ 9. Spring Advanced Security

## 05-spring-security-default.md

### 1\. Spring Security Setup

To integrate Spring Security, only one starter dependency is required. Spring Boot handles the auto-configuration for the necessary filters and components.

#### Maven (`pom.xml`)

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

### 2\. Default Out-of-the-Box Behavior

Once the dependency is added and the application restarts, Spring Security performs the following "magic" automatically:

  * **Secures All Endpoints:** By default, every HTTP request to the application (except static resources like CSS/JS) requires **authentication**.
  * **Generates Login Page:** A basic, functional **login form** is automatically generated and served at the `/login` URL.
  * **Creates Default User:** Spring creates a temporary, in-memory user named **`user`**.
  * **Generates Temporary Password:** A unique, random **password** is generated at runtime and printed to the console log (prefixed with `Using generated security password`). This password is valid until the application restarts.
  * **Registers Filters:** Spring registers a chain of **Security Filters** (most notably the `FilterChainProxy`) that intercepts every incoming request.

### 3\. Overriding Default Credentials

While the auto-generated password is secure, it is impractical for development. You can easily override the default user credentials using the `application.properties` file for testing purposes.

#### `application.properties` Override

```properties
# Overrides the default "user" credentials
spring.security.user.name=admin
spring.security.user.password={noop}mydevpassword 
spring.security.user.roles=USER, ADMIN
```

  * **Important:** The prefix **`{noop}`** tells Spring Security to use a **`NoOpPasswordEncoder`**â€”meaning the password is not encoded. **This should only ever be used for non-production testing**; it's highly insecure for live systems.

-----

### 4\. Custom In-Memory User Configuration

For slightly more control over users and roles without touching a database, you can define users programmatically using the **`InMemoryUserDetailsManager`**. This also requires defining a **`PasswordEncoder`** bean.

#### A. The `PasswordEncoder` Requirement

Spring Security **requires** that all passwords be encoded. You must expose a `PasswordEncoder` bean to the Spring container, typically using **`BCryptPasswordEncoder`**.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {

    @Bean // 1. Defines the required PasswordEncoder bean
    public PasswordEncoder passwordEncoder() {
        // BCrypt is the standard, highly secure hashing algorithm
        return new BCryptPasswordEncoder();
    }

    // ... In-Memory User Manager Definition (see below)
}
```

#### B. Defining Custom Users

You define the users, ensuring their passwords are **hashed** before being passed to the manager.

```java
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
// ... imports

@Configuration
public class SecurityConfig {
    
    // ... passwordEncoder() bean above ...

    @Bean // 2. Defines the manager for in-memory authentication
    public InMemoryUserDetailsManager userDetailsManager(PasswordEncoder passwordEncoder) {
        
        // Define an admin user
        UserDetails admin = User.builder()
            .username("alice")
            // Pass the plain-text password to the encoder
            .password(passwordEncoder.encode("secret123")) 
            .roles("USER", "ADMIN")
            .build();
            
        // Define a regular user
        UserDetails user = User.builder()
            .username("bob")
            .password(passwordEncoder.encode("userpass"))
            .roles("USER")
            .build();
            
        // Returns a manager containing the defined users
        return new InMemoryUserDetailsManager(admin, user);
    }
}
```

This configuration effectively **overrides** the default generated user and password, allowing you to use `alice/secret123` or `bob/userpass` to access the secured application.

In the subsequent sections, we will move from this in-memory setup to a production-ready system where user details are loaded from a database (using JPA).

