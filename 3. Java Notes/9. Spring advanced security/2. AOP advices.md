# ðŸ”’ 9. Spring Advanced Security

## 02-aop-advices.md

### 1\. Understanding Advice

**Advice** is the action or code segment that an **Aspect** executes at a specific **Join Point** (method execution). The five types of advice define the **timing** of the execution.

-----

### 2\. Types of Advice

All Advice annotations must refer to a defined **Pointcut** expression, specifying *where* in the code the Advice should be applied. We will reuse the Pointcut defined previously:

```java
// Reusable Pointcut defined in the Aspect class
@Pointcut("execution(* com.app.service.*.*(..))")
public void serviceMethodsPointcut() {}
```

#### A. `@Before` Advice

The `@Before` advice executes **before** the target method is called. It cannot prevent the target method from executing unless it throws an exception itself.

  * **Use Case:** Security checks, parameter validation, or logging the start of a method.
  * **Syntax:** `@Before("pointcut_name")`

<!-- end list -->

```java
@Before("serviceMethodsPointcut()")
public void logMethodCall(JoinPoint joinPoint) {
    // JoinPoint provides context about the advised method
    String methodName = joinPoint.getSignature().toShortString();
    System.out.println(">>> @Before: Executing method: " + methodName);
    
    // Accessing method arguments:
    Object[] args = joinPoint.getArgs();
    System.out.println("Arguments: " + Arrays.toString(args));
}
```

#### B. `@AfterReturning` Advice

The `@AfterReturning` advice executes **after** the target method has completed successfully (i.e., without throwing any exception).

  * **Use Case:** Post-processing successful results, auditing successful transactions, or logging the return value.
  * **Syntax:** `@AfterReturning(pointcut = "pointcut_name", returning = "result_variable")`

<!-- end list -->

```java
// The 'result' parameter receives the return value of the advised method
@AfterReturning(
    pointcut = "serviceMethodsPointcut()",
    returning = "result" 
)
public void logSuccessfulReturn(JoinPoint joinPoint, Object result) {
    String methodName = joinPoint.getSignature().toShortString();
    System.out.println("<<< @AfterReturning: Method: " + methodName + " returned successfully.");
    if (result != null) {
        // Can inspect the return value
        System.out.println("Result value is: " + result.getClass().getName());
    }
}
```

#### C. `@AfterThrowing` Advice

The `@AfterThrowing` advice executes **after** the target method throws an exception.

  * **Use Case:** Centralized logging of exceptions, sending error notifications, or custom rollback handling.
  * **Syntax:** `@AfterThrowing(pointcut = "pointcut_name", throwing = "exception_variable")`

<!-- end list -->

```java
// The 'ex' parameter receives the exception object thrown by the target method
@AfterThrowing(
    pointcut = "serviceMethodsPointcut()",
    throwing = "ex" 
)
public void logException(JoinPoint joinPoint, Throwable ex) {
    String methodName = joinPoint.getSignature().toShortString();
    System.out.println("!!! @AfterThrowing: Method: " + methodName + " threw an exception!");
    // Can inspect and log the exception details
    System.err.println("Exception: " + ex.getMessage());
}
```

#### D. `@After` (Finally) Advice

The `@After` advice executes **after** the target method completes, **regardless** of whether it returned normally or threw an exception (similar to a Java `finally` block).

  * **Use Case:** Resource cleanup (though usually done by Spring), closing external connections, or general auditing of method completion.
  * **Syntax:** `@After("pointcut_name")`

<!-- end list -->

```java
@After("serviceMethodsPointcut()")
public void logMethodEnd(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().toShortString();
    System.out.println("--- @After: Method: " + methodName + " execution finished.");
}
```

-----

### 3\. `@Around` Advice (The Most Powerful)

The `@Around` advice is a single method that **surrounds** the execution of the target method. It combines the functionality of `@Before`, `@AfterReturning`, and `@AfterThrowing` into one.

  * **Power:** It has explicit control over when the target method runs (`proceed()`), can modify the arguments before they reach the target, and can modify the return value.
  * **Parameter:** It requires a parameter of type **`ProceedingJoinPoint`**.

#### Syntax and Execution Flow:

```java
@Around("serviceMethodsPointcut()")
public Object aroundExecution(ProceedingJoinPoint pjp) throws Throwable {
    
    // 1. Logic BEFORE the target method runs (Pre-processing)
    System.out.println(">>> @Around: Starting timer...");

    long start = System.currentTimeMillis();

    try {
        // 2. Execution: This is where the target method is called.
        // The return value of proceed() is the return value of the target method.
        Object result = pjp.proceed(); 

        // 3. Logic AFTER target method returns (Post-processing)
        long end = System.currentTimeMillis();
        System.out.println("<<< @Around: Method took " + (end - start) + "ms.");
        
        // 4. Return the result (or a modified result)
        return result; 

    } catch (Exception ex) {
        // 5. Logic if target method throws an exception
        System.err.println("!!! @Around: Method failed with: " + ex.getMessage());
        throw ex; // Must re-throw the exception to maintain application flow
    }
}
```

Due to its complexity and control over transaction boundaries (like calculating execution time), the `@Around` advice is so important that the next module is dedicated solely to mastering its implementation.
