# ðŸ”’ 9. Spring Advanced Security

## 06-csrf-handling.md

### 1\. What is Cross-Site Request Forgery (CSRF)?

**CSRF** is an attack that forces an authenticated user to execute unwanted actions on a web application in which they are currently logged in.

The core of the attack relies on the fact that web browsers automatically include **session cookies** (which prove authentication) with any request made to the domain, regardless of where the request originated.

#### Mechanics of the Attack

1.  A user (`Alice`) is logged into a vulnerable banking site (`bank.com`).
2.  Alice visits a malicious site (`attacker.com`).
3.  The malicious site contains an invisible form or an image tag that sends a **state-changing request** to the bank's server.
      * *Example:* A hidden form submits a `POST` request to `bank.com/transfer?amount=1000&to=attacker`.
4.  The browser automatically includes Alice's valid `bank.com` session cookie.
5.  The bank's server processes the request as a legitimate action from Alice, and the unauthorized action is executed.

### 2\. Why is CSRF Protection Necessary?

CSRF is dangerous because it targets methods that change application state (data modification).

| Vulnerable HTTP Methods | Safe HTTP Methods |
| :--- | :--- |
| **`POST`** (Creation) | `GET` (Retrieval) |
| **`PUT`** (Full Update) | `HEAD` |
| **`DELETE`** (Deletion) | `OPTIONS` |
| **`PATCH`** (Partial Update) | |

`GET` requests are typically safe because they should only retrieve data and never change server state.

### 3\. Spring Security's CSRF Defense Mechanism

Spring Security provides robust defense against CSRF that is **enabled by default**.

The defense mechanism relies on a unique, secret, unpredictable value known as the **CSRF Token**.

#### How the CSRF Token Works:

1.  **Generation:** When a user first accesses the site, the server generates a unique **CSRF token** and stores it in the user's HTTP session.
2.  **Delivery:** The token is sent to the client.
3.  **Submission:** For any state-changing request (`POST`, `PUT`, `DELETE`), the client must retrieve this token and include it in the request (either in a hidden form field or a custom HTTP header).
4.  **Validation:** The server compares the token received in the request against the token stored in the user's session. If they do not match, the request is rejected with an **HTTP 403 Forbidden** status.

Since a malicious attacker cannot read data from your application (due to Same-Origin Policy), they cannot obtain the unique, secret CSRF token, thus failing the forged request.

### 4\. CSRF Handling in Modern Applications

The way you handle the CSRF token depends on your frontend architecture.

#### A. Traditional Server-Side Rendered (MVC)

If you use Spring MVC with a templating engine (like Thymeleaf):

  * **Automatic:** Spring Security and the template engine automatically inject a hidden input field containing the CSRF token into every `<form>` tag that uses a `POST` method.

<!-- end list -->

```html
<form method="POST" action="/transfer">
    <input type="hidden" name="_csrf" value="[Generated CSRF Token]"> 
    </form>
```

#### B. Single-Page Applications (SPAs) and REST APIs

In a modern REST architecture where the frontend (React, Angular, Vue) is decoupled, the SPA must manually retrieve and send the token:

1.  **Retrieve Token:** The frontend usually makes an initial `GET` request (which is CSRF-exempt) to an endpoint. Spring Security often delivers the token via a custom **HTTP Header** or a **Cookie**.
2.  **Set Header:** The frontend must then include the retrieved token in a custom header for all subsequent state-changing requests.

<!-- end list -->

  * **Standard Header Name:** `X-CSRF-TOKEN` (preferred by Spring)
  * **Default Field Name:** `_csrf`

**Example: Sending the Token from a Frontend (Axios)**

```javascript
// Assuming token was retrieved and stored in a variable
const csrfToken = 'a1b2c3d4e5f6'; 

axios.post('/api/jobs', newJobData, {
    // Manually adding the CSRF token to the request header
    headers: {
        'X-CSRF-TOKEN': csrfToken 
    }
})
// ...
```

### 5\. Disabling CSRF Protection (When and Why)

While CSRF protection is crucial, there are specific scenarios where it might be disabled:

1.  **Stateless REST APIs:** If your API is purely stateless, serving only non-browser clients (e.g., mobile apps, other microservices), and relies entirely on token-based authentication (like **JWT**) carried in the header, CSRF protection is often redundant and can be disabled for simplicity.
2.  **Stateless Services:** If you explicitly ensure that no endpoint relies on a session cookie for authentication.

#### Code to Disable CSRF (Use with Extreme Caution\!)

You can disable CSRF in your main security configuration class by overriding the default security filter chain:

```java
import org.springframework.security.web.SecurityFilterChain;
// ...

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        // Disables CSRF protection
        .csrf(csrf -> csrf.disable()) 
        
        // Ensure you configure other security rules
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated()); 
        
    return http.build();
}
```
