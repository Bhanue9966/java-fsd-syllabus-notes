# ðŸ”’ 9. Spring Advanced Security

## 07-custom-user-details.md

### 1\. The Need for Custom User Details

The **`InMemoryUserDetailsManager`** (covered in the previous module) is only suitable for development and testing. For a production application, user accounts, roles, and encrypted passwords must be stored persistently in a database (like PostgreSQL, MySQL, etc.), which requires Spring to fetch these details via JPA.

To achieve this, we need to implement two core Spring Security interfaces:

1.  **`UserDetails`**: Defines the user data structure.
2.  **`UserDetailsService`**: Defines the method for loading the user data.

### 2\. Implementing the `UserDetails` Interface (The Entity)

The **`UserDetails`** interface represents the core user security data (username, password, authorities, and account status flags). In a JPA application, we typically make our user **Entity** implement this interface.

#### Code Example: The `User` Entity

```java
package com.app.entity;

import jakarta.persistence.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

// JPA Entity
@Entity
@Table(name = "users")
public class User implements UserDetails { 
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Must be unique
    private String username; 
    
    // Stores the BCrypted hash
    private String password; 
    
    // Simple role field (e.g., "ROLE_USER", "ROLE_ADMIN")
    private String role; 

    // --- Core UserDetails Methods ---

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // Converts the role string into a security authority object
        return List.of(new SimpleGrantedAuthority(role));
    }

    // Getters for password and username are automatically used by Spring Security
    @Override
    public String getPassword() {
        return password; 
    }

    @Override
    public String getUsername() {
        return username; 
    }

    // --- Account Status Flags (Crucial for Security) ---

    // Setting these to true by default, but they can be tied to fields
    // in the database (e.g., a locked_until date or boolean flags)
    @Override
    public boolean isAccountNonExpired() {
        return true; 
    }

    @Override
    public boolean isAccountNonLocked() {
        return true; 
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true; 
    }

    @Override
    public boolean isEnabled() {
        return true; // Set to false for email verification flow
    }
}
```

### 3\. Implementing the `UserDetailsService` Interface (The Loader)

The **`UserDetailsService`** interface has a single method, `loadUserByUsername()`, which Spring Security calls during the authentication process to retrieve user details from the persistent store.

#### Code Example: The Custom Service

```java
package com.app.service;

import com.app.entity.User;
import com.app.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service // Spring automatically finds this bean
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * Finds and loads the UserDetails object for the given username.
     * This is the bridge between Spring Security and our database.
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
        // 1. Use the JPA Repository to fetch the entity
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> 
                // 2. Throws the required exception if the user is not found
                new UsernameNotFoundException("User not found with username: " + username)
            );

        // 3. Since our User entity implements UserDetails, we return it directly.
        return user; 
    }
}
```

### 4\. Configuration and Automatic Wiring

When using Spring Boot, the framework handles the final step:

  * When the authentication system initializes, it searches the Spring container for a bean that implements **`UserDetailsService`**.
  * Because we annotated our `CustomUserDetailsService` with `@Service`, Spring automatically finds and registers it.

This means that every time a user attempts to log in:

1.  Spring receives the username and raw password.
2.  It calls our `CustomUserDetailsService.loadUserByUsername(username)`.
3.  Our service returns the `User` object (which holds the **hashed password**).
4.  Spring Security uses the registered **`PasswordEncoder`** to hash the raw login password and compares it against the hashed password from the database.
5.  If the hashes match, the user is authenticated, and the `User` object (now the `Principal`) is stored in the security context.
