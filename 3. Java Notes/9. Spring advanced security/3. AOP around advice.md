# ðŸ”’ 9. Spring Advanced Security

## 03-aop-around-advice.md

### 1\. Mastering the `@Around` Advice

The **`@Around`** advice is the ultimate interceptor in Spring AOP. Unlike the other advice types (`@Before`, `@AfterReturning`, etc.) which simply execute *at* a fixed point, `@Around` **surrounds** the execution of the target method, giving the developer complete control over the entire process.

#### Unique Capabilities of `@Around`:

1.  **Invocation Control:** It decides *when* (or *if*) the target method is executed using the `proceed()` method.
2.  **Argument Modification:** It can inspect and modify the arguments passed to the target method before proceeding.
3.  **Result Manipulation:** It can inspect and modify the result returned by the target method, or even suppress the result and return a completely different value.
4.  **Comprehensive Error Handling:** It can use a standard `try-catch-finally` block to handle successful returns, exceptions, and cleanup all in one place.

### 2\. The `ProceedingJoinPoint` Object

The `@Around` advice method **must** accept an argument of type **`ProceedingJoinPoint`**.

| Method | Purpose | Notes |
| :--- | :--- | :--- |
| **`pjp.proceed()`** | **Delegates the call** to the target method. This is the crucial point where the business logic runs. | It returns the value returned by the target method. It must be called, and it **throws `Throwable`**. |
| `pjp.getSignature()` | Provides details about the advised method (name, return type, etc.). | |
| `pjp.getArgs()` | Returns an array of arguments passed to the advised method. |

### 3\. Practical Example: Method Execution Time

One of the most common applications of `@Around` is calculating the time a business method takes to execute, often known as method profiling. This requires actions both before and after the method runs.

#### Aspect Definition: Execution Timer

```java
package com.app.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class PerformanceAspect {
    
    // Define a pointcut to advise methods annotated with a custom @TrackTime annotation
    @Around("@annotation(com.app.annotations.TrackTime)")
    public Object timeMethodExecution(ProceedingJoinPoint pjp) throws Throwable {
        
        // 1. Logic BEFORE execution (Start Timer)
        long startTime = System.currentTimeMillis();
        String methodName = pjp.getSignature().toShortString();
        
        Object result = null;
        
        try {
            // 2. Execution of Target Method (The 'Proceed' Step)
            System.out.println("Starting execution of: " + methodName);
            result = pjp.proceed(); // Executes the method in the Service Layer
            
        } catch (Exception ex) {
            // 3. Logic ON EXCEPTION (Handle Failure)
            System.err.println("Method " + methodName + " failed with: " + ex.getMessage());
            throw ex; // Important: Re-throw the exception to maintain error propagation
        }
        
        // 4. Logic AFTER execution (Stop Timer & Log Result)
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        
        System.out.println("Finished execution of: " + methodName);
        System.out.println("--- Execution Time: " + duration + "ms ---");

        // 5. Return the original result
        return result;
    }
}
```

#### Application of the Aspect

Assuming we have a custom annotation `@TrackTime`, we can apply the timing aspect to any slow business method:

```java
// src/main/java/com/app/service/DataService.java

@Service
public class DataService {

    // The Aspect will intercept this call because of the annotation.
    @TrackTime
    public List<Data> fetchLargeDataset() throws InterruptedException {
        // Simulate a long database query
        Thread.sleep(1200); 
        return List.of(new Data("A"), new Data("B"));
    }
}
```

When `fetchLargeDataset()` is called, the output demonstrates the `try-catch-finally` flow managed by the `@Around` advice:

```
Starting execution of: DataService.fetchLargeDataset()
Finished execution of: DataService.fetchLargeDataset()
--- Execution Time: 1202ms ---
```

