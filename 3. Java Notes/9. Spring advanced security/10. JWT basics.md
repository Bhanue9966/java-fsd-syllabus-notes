# ðŸ”’ 9. Spring Advanced Security

## 10-jwt-basics.md

### 1\. Introduction to JSON Web Tokens (JWT)

A **JSON Web Token (JWT)** is an open standard (**RFC 7519**) that defines a compact and secure way for transmitting information between parties as a JSON object.

  * **Stateless Authentication:** JWTs are primarily used to replace traditional **session-based authentication**. Instead of the server storing user state in a session, all necessary user information (like ID and roles) is self-contained within the token itself.
  * **Key Advantage:** Since the server doesn't need to look up a session ID in a database for every request, the application becomes easily scalable across multiple servers (stateless).

### 2\. The Structure of a JWT

A JWT is a single string that consists of three parts, separated by dots (`.`):

$$\text{Header} \textbf{.} \text{Payload} \textbf{.} \text{Signature}$$

#### A. Header (Algorithm)

The header contains metadata about the token, typically specifying the type of token (`JWT`) and the **hashing algorithm** used for the signature (e.g., `HMAC SHA256` or `RSA`).

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### B. Payload (Claims)

The payload contains the **claims**, which are the actual pieces of information about the user and the token itself.

| Claim Type | Key | Description |
| :--- | :--- | :--- |
| **Registered** | `exp` | **Expiration time** (mandatory for security). |
| **Registered** | `sub` | **Subject**, usually the User ID or username. |
| **Public** | `iss` | Issuer (who created the token). |
| **Private** | `roles` | Custom claim, such as the user's roles (`ROLE_ADMIN`). |

```json
{
  "sub": "alice",
  "roles": ["ROLE_ADMIN"],
  "exp": 1672531200 // Expiration time in seconds (UTC timestamp)
}
```

#### C. Signature

The signature is used by the server to **verify the token's integrity** (i.e., ensure the header and payload haven't been tampered with).

1.  The server takes the Base64-encoded Header and the Base64-encoded Payload.
2.  It combines them with a secret key known **only** to the server.
3.  It hashes the result using the algorithm specified in the header.

$$\text{Signature} = \text{HMACSHA256}(\text{base64UrlEncode}(\text{Header}) + "." + \text{base64UrlEncode}(\text{Payload}), \text{Server\_Secret})$$

If the calculated signature matches the signature provided in the token, the token is deemed **valid and untampered**.

### 3\. The JWT Authentication Flow

1.  **Login:** The user sends credentials (`username`, `password`) to a dedicated login endpoint (`/api/auth/login`).
2.  **Authentication & Issuance:** Spring authenticates the user. If successful, a **JWT is generated** using the server's secret key and sent back to the client in the HTTP response body.
3.  **Subsequent Requests:** The client stores the JWT (e.g., in local storage) and includes it in the **Authorization header** of every subsequent protected API call.
      * **Header Format:** `Authorization: Bearer [The JWT String]`
4.  **Validation:** The server intercepts the request, extracts the token, verifies the signature using the secret key, checks the expiration time (`exp`), and loads the user identity from the claims.

### 4\. Security Considerations

  * **HTTPS/TLS:** JWTs must *always* be sent over a secure connection (**HTTPS**) to prevent them from being intercepted, as the payload is only encoded (Base64), not encrypted.
  * **Token Expiration:** The `exp` claim is critical. Short expiration times (e.g., 15 minutes) reduce the window of opportunity for attackers to use a stolen token.
  * **Secret Key Management:** The server's secret key must be strong and secured, as compromising it allows an attacker to forge valid tokens.
