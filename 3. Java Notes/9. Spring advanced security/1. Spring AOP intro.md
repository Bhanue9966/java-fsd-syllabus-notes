# ðŸ”’ 9. Spring Advanced Security

## 01-spring-aop-intro.md

### 1\. What is Aspect-Oriented Programming (AOP)?

**Aspect-Oriented Programming (AOP)** is a programming paradigm that aims to increase modularity by separating **cross-cutting concerns**.

  * **Core Goal:** To modularize features that are spread across multiple classes (cross-cutting) but are not central to the business logic of those classes.
  * **Analogy:** If your application is a cake, the business logic (like creating a user or placing an order) is the flour and sugar. The cross-cutting concerns (like logging every transaction or checking security permissions) are the baking powder, which needs to touch every layer but isn't part of the core ingredients.

### 2\. Cross-Cutting Concerns

These are functionalities needed by virtually every module in the application:

| Concern | Description |
| :--- | :--- |
| **Logging** | Recording method entry/exit, arguments, and execution time. |
| **Security** | Checking user authorization before method execution. |
| **Transaction** | Starting and committing database transactions. |
| **Caching** | Checking a cache before hitting the database. |

Without AOP, developers would repeat the logging/security code in every business method, leading to code duplication and difficulty in maintenance.

-----

### 3\. AOP Terminology and Concepts

AOP introduces specialized terminology to define *what* needs to be done and *where* it needs to be applied.

| Term | Description | Spring AOP Example |
| :--- | :--- | :--- |
| **Aspect** | A modular unit that encapsulates the cross-cutting concern. It is a class annotated with **`@Aspect`**. | `LoggingAspect` class |
| **Join Point** | An execution point in the application where an aspect's logic can be inserted. In Spring AOP, this is always a **method execution**. | The moment a method like `createUser()` is called. |
| **Advice** | The action taken by an aspect at a particular join point. It is the actual code (method) that runs. | The Java method in the aspect that handles logging. |
| **Pointcut** | A predicate or expression that matches and identifies a set of join points (i.e., defines *where* the Advice should run). | `execution(* com.app.service.*.*(..))` |
| **Target Object** | The object whose method is being advised (e.g., the `UserService` instance). |
| **Weaving** | The process of linking aspects with the target objects to create an advised object (at compile-time, load-time, or runtime). Spring AOP uses **runtime weaving** via proxies. |

-----

### 4\. Defining an Aspect and Pointcut (Syntax and Example)

To use AOP in Spring, you need to enable it and define your aspect using annotations.

#### A. Enable AOP

In a Spring Boot application, you simply annotate a configuration class (often the main application class) with:

```java
// On a @Configuration or @SpringBootApplication class
@EnableAspectJAutoProxy
```

#### B. Defining the Aspect and Pointcut

This example creates a logging aspect that advises all methods within the `com.app.service` package.

**Syntax: `@Aspect` and `@Pointcut`**

```java
package com.app.aop;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect // 1. Marks this class as an Aspect
@Component 
public class LoggingAspect {

    // 2. Define a reusable Pointcut expression 
    //    Syntax: execution(return_type package.Class.method(arguments))
    @Pointcut("execution(* com.app.service.*.*(..))")
    public void serviceMethodsPointcut() {
        // This method body is empty; it just provides a name for the pointcut
    }
    
    // The Advice will be defined in the next module, using the defined Pointcut
    // For example: @Before("serviceMethodsPointcut()")
    // public void beforeLog(JoinPoint joinPoint) { ... }
}
```

#### C. Pointcut Expression Syntax (`execution`)

The `execution` designator is the most commonly used for method execution join points.

| Component | Meaning | Example |
| :--- | :--- | :--- |
| `*` | Matches any return type. | `execution(* ...` |
| `com.app.service.*` | Matches any class in the `com.app.service` package. | `... com.app.service.*. ...` |
| `*(..)` | Matches any method name (`*`) with any number of arguments (`..`). | `... *(..))` |
| `(String, *)` | Matches methods with exactly two arguments: a `String` and any other type. |

**Example Pointcut:** `execution(public * com.app.service.UserService.find*(..))`

  * *Matches:* Any public method in `UserService` whose name starts with `find`, taking any number of arguments.

-----

### 5\. How Spring AOP is Implemented (Weaving)

Spring AOP implements AOP at **runtime** using **Proxies**. Spring does not modify the bytecode of the original class.

1.  When Spring sees a bean (Target Object) needs to be advised (because it matches a Pointcut), Spring creates a **Proxy Object**.
2.  The Proxy Object has the same interface as the Target Object.
3.  When a client calls a method on the Target Object, the call is intercepted by the **Proxy**.
4.  The Proxy executes the Advice code (the logic from the Aspect) and then delegates the call to the original Target Object.

This means Spring AOP can only advise **public methods** and cannot advise methods called internally within the target object itself (`this.someMethod()`).

