# üîó Collections, Exceptions, Concurrency

## 18\. Parallel Streams

A **Parallel Stream** is a stream that executes its operations concurrently using multiple threads, utilizing the underlying multicore architecture of the processor. This is a form of automatic data-level parallelism, designed to speed up tasks involving large datasets.

### 1\. How Parallel Streams Work ‚öôÔ∏è

1.  **Splitting:** When you invoke `parallelStream()`, the stream source is divided into multiple independent substreams using a mechanism called a **Spliterator**.
2.  **Execution:** Each substream is processed concurrently by a different thread. By default, Java uses the shared **Fork-Join Pool** (a thread pool optimized for recursive tasks) for execution. The number of threads used is typically equal to the number of available processor cores minus one.
3.  **Combination:** The results from all substreams are merged back together to produce the final output.

### 2\. Creating a Parallel Stream

There are two primary ways to obtain a parallel stream:

| Method | Description | Example |
| :--- | :--- | :--- |
| **`parallelStream()`** | Used when starting from a `Collection` (e.g., `List`, `Set`). This is the most common way. | `myList.parallelStream()` |
| **`parallel()`** | Used to convert an existing sequential stream into a parallel stream mid-pipeline. | `myList.stream().filter(...).parallel().map(...)` |

### 3\. Performance Considerations (When to Use)

Parallel streams are **not always faster** than sequential streams. The overhead of splitting the data, managing the threads, and combining the results can sometimes outweigh the benefit of parallel execution.

| Use Case | Recommendation | Rationale |
| :--- | :--- | :--- |
| **Large Data Sets** | ‚úÖ **Use Parallel** | The cost of overhead is minimal compared to the time saved processing the massive data chunks. |
| **Small Data Sets** | ‚ùå **Use Sequential** | The overhead of parallelization will dominate execution time. |
| **I/O Bound Tasks** | ‚ùå **Avoid Parallel** | Tasks waiting on external resources (network, disk) spend most time idle; adding more threads won't make the disk faster. |
| **CPU Bound Tasks** | ‚úÖ **Use Parallel** | Tasks that involve heavy computations (e.g., complex math, encryption) benefit most from parallel execution. |
| **Order-Dependent Tasks** | ‚ùå **Avoid Parallel** | Operations like `forEachOrdered` or using `limit()` on an unsorted stream can negate parallel speed gains, as they force ordering constraints. |

### 4\. Danger: Shared Mutable State

If any part of the parallel stream pipeline (especially the **terminal operation**) modifies a shared variable outside of the stream, it can lead to **Race Conditions** (as discussed in Section 12).

**Bad Example (Race Condition):**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3);
int total = 0;

// DANGEROUS: total is a shared mutable variable
numbers.parallelStream().forEach(n -> {
    total += n; // RACE CONDITION on 'total'
});
// 'total' will likely be incorrect.
```

**Safe Alternative (Reduction):**

The `collect()` and `reduce()` terminal operations are thread-safe because they handle the intermediate results in isolation before combining them safely.

```java
// SAFE: Stream handles the combination safely internally
int safeTotal = numbers.parallelStream().reduce(0, Integer::sum);
```

