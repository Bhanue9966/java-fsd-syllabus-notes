# ðŸ”— Collections, Exceptions, Concurrency

## 8\. The `throws` Keyword and `try-with-resources`

### 1\. The `throws` Keyword ðŸ“¢

The **`throws`** keyword is used in a method signature to explicitly declare the type of **Checked Exceptions** that the method is capable of throwing.

  * **Purpose:** It delegates the responsibility of handling the specified exception to the **caller** of the method.
  * **Usage:** It is mandatory for Checked Exceptions that are not handled within the method using a `try-catch` block. It is optional for Unchecked Exceptions.
  * **Location:** It is placed after the method signature and before the opening curly brace.

#### Example: Delegating Responsibility

```java
import java.io.FileReader;
import java.io.IOException;

public class Delegator {
    
    // The method DOES NOT handle the IOException, it declares that it might throw it.
    public void readFile(String fileName) throws IOException { 
        System.out.println("Attempting to read file...");
        // This constructor might throw a Checked Exception (FileNotFoundException, a subclass of IOException)
        FileReader reader = new FileReader(fileName); 
        
        // ... file reading logic ...
        reader.close();
    }

    public static void main(String[] args) {
        Delegator d = new Delegator();
        
        try {
            // The caller (main method) must now handle the IOException
            d.readFile("config.txt"); 
            System.out.println("File read successfully.");
        } catch (IOException e) {
            // The handling logic is here
            System.err.println("Error reading file: " + e.getMessage());
        }
    }
}
```

### 2\. The `try-with-resources` Statement (Java 7+) ðŸ§¹

In older Java versions, resources like file streams or database connections had to be explicitly closed in a `finally` block to prevent resource leaks. The **`try-with-resources`** statement automates this process.

  * **Purpose:** Ensures that each resource opened in the `try` statement is automatically and safely closed after the `try` block finishes, regardless of whether an exception occurred or not.
  * **Requirement:** The resource being used **must implement the `java.lang.AutoCloseable` interface**. Most I/O and database resources do.
  * **Syntax:** Resources are declared and initialized inside the parentheses immediately following the `try` keyword.

#### Example: Automatic Resource Closing

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class ResourceCleanupDemo {
    public static void main(String[] args) {
        String fileName = "data.txt";
        
        // 1. Resource declared inside the try parentheses
        try (
            FileReader fr = new FileReader(fileName); // Resource 1
            BufferedReader br = new new BufferedReader(fr); // Resource 2
        ) {
            // 2. Use the resources
            String line = br.readLine();
            System.out.println("First line: " + line);
            
        } catch (IOException e) {
            // 3. Catch block handles any potential exceptions
            System.err.println("File operation error: " + e.getMessage());
            
        } // 4. No finally block needed! fr and br are automatically closed here.
    }
}
```

#### Comparison to Traditional `finally`

| Feature | `try-with-resources` | Traditional `finally` |
| :--- | :--- | :--- |
| **Cleanup** | **Automatic**; resources closed at the end of `try`. | **Manual**; requires explicit `resource.close()` call inside `finally`. |
| **Code** | **Cleaner** and more concise. | Often **verbose** due to nested `try-catch` within `finally`. |
| **Safety** | **Superior**; handles exceptions during the closing process (suppressed exceptions). | Closing resources manually can also throw exceptions, which must be handled. |

