# ðŸ”— Collections, Exceptions, Concurrency

## 1\. The Java Collections API: Core Concepts and Structure

The **Java Collections Framework (JCF)** provides a set of interfaces and classes for unified data structure management, offering dynamic size and rich functionality far beyond native arrays.

### 1\. Classification of the Collections Framework ðŸŒ³

The JCF is divided into two primary root branches: the **`Collection`** interface (for single-unit data) and the **`Map`** interface (for key-value data).

| Root Interface | Structure | Primary Characteristics |
| :--- | :--- | :--- |
| **`Collection`** | Stores a group of individual elements. | Supports dynamic size, rich utility methods. |
| **`Map`** | Stores Key-Value pairs. | Keys must be unique; not iterable directly via `Iterator`. |

-----

### 2\. The Core Interfaces and Implementations

The `Collection` interface extends to three main sub-interfaces, each defining a unique data structure contract.

#### A. The `List` Interface (Ordered & Duplicates Allowed)

A list is an ordered sequence (like an array, but dynamic). It guarantees the insertion order.

  * **Characteristics:** **Ordered** (index-based) and **Allows duplicates**.
  * **Common Implementations:** `ArrayList` (array-backed, fast random access), `LinkedList` (node-based, fast insertions/deletions).
  * **List-Specific Methods (in addition to `Collection` methods):**
      * `get(int index)`: Retrieves the element at the specified position.
      * `add(int index, E element)`: Inserts an element at a specific position.

<!-- end list -->

```java
// Example: Demonstrating order and duplicates
List<String> planets = new ArrayList<>();
planets.add("Earth");
planets.add("Mars");
planets.add("Earth"); // Duplicates allowed

System.out.println(planets);     // Output: [Earth, Mars, Earth] (Order preserved)
System.out.println(planets.get(1)); // Output: Mars (Access by index)
```

#### B. The `Set` Interface (No Duplicates)

A set is a collection that cannot contain duplicate elements.

  * **Characteristics:** **No duplicates**.
  * **Common Implementations:** `HashSet` (fast, does not maintain order), `LinkedHashSet` (maintains insertion order), `TreeSet` (maintains sorted order).

<!-- end list -->

```java
// Example: Demonstrating no duplicates
Set<String> uniqueColors = new HashSet<>();
uniqueColors.add("Red");
uniqueColors.add("Green");
uniqueColors.add("Red"); // Duplicate is ignored

System.out.println(uniqueColors); // Output: [Red, Green] (Size is 2)
System.out.println(uniqueColors.contains("Green")); // Output: true
```

#### C. The `Map` Interface (Key-Value Pairs)

A map stores data in pairs, where each unique **key** is associated with a **value**. It is separate from the `Collection` hierarchy.

  * **Characteristics:** **Unique keys**, values can be duplicated.
  * **Common Implementations:** `HashMap` (fast, no order guarantee), `LinkedHashMap` (maintains insertion order), `TreeMap` (maintains sorted key order).
  * **Map-Specific Methods:**
      * `put(K key, V value)`: Inserts a key-value pair.
      * `get(Object key)`: Returns the value associated with the specified key.
      * `keySet()`: Returns a `Set` of all keys.
      * `values()`: Returns a `Collection` of all values.

<!-- end list -->

```java
// Example: Key-Value pairs
Map<Integer, String> students = new HashMap<>();
students.put(101, "Alice");
students.put(102, "Bob");
students.put(101, "Alex"); // Key 101 already exists, value is overwritten

System.out.println(students.get(101)); // Output: Alex (Overwritten value)
System.out.println(students.containsKey(102)); // Output: true
```

-----

### 3\. Generics: Type Safety in Collections

**Generics** are essential for using the JCF effectively by providing **type checking at compile time**, preventing common runtime errors.

| Concept | Code | Description |
| :--- | :--- | :--- |
| **Type Definition** | `List<String> names = new ArrayList<>();` | Specifies that this list can *only* hold `String` objects. |
| **Compile-Time Error** | `names.add(5);` | This line will cause a **compile error**, protecting the collection's integrity. |
| **Type Elimination** | Internally, Java performs **type erasure** at runtime, treating the list as a raw `List` of `Object`, but the compiler handles the safety checks. | |

-----

### 4\. Iterators for Traversal

The **`Iterator`** interface provides a standardized, safe mechanism to loop through all elements of a **`Collection`** (List, Set, Queue).

```java
List<String> fruits = new ArrayList<>();
fruits.add("Apple");
fruits.add("Banana");

Iterator<String> iterator = fruits.iterator();

// Looping through elements
while (iterator.hasNext()) {
    String fruit = iterator.next();
    System.out.println("Processing: " + fruit);
    
    // Key Feature: Safe removal of elements while iterating
    if (fruit.equals("Apple")) {
        iterator.remove(); 
    }
}
System.out.println(fruits); // Output: [Banana]
```

