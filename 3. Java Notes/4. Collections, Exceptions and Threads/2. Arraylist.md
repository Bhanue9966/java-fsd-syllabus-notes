# ðŸ”— Collections, Exceptions, Concurrency

## 2\. ArrayList

The **`ArrayList`** class is the resizable array implementation of the **`List`** interface. It is one of the most frequently used classes in the Java Collections Framework due to its simple, array-like structure combined with dynamic resizing.

### 1\. Key Characteristics of `ArrayList`

  * **Implementation:** Internally, `ArrayList` uses a dynamically allocated **Object array**.
  * **Indexing:** It is an **indexed** data structure, meaning elements are stored in the order of insertion and can be accessed by their numerical index (`0` to `size - 1`).
  * **Duplicates:** **Allows** duplicate elements.
  * **Capacity:** When the underlying array runs out of space, the `ArrayList` automatically creates a new, larger array (typically 50% larger than the current capacity) and copies all elements to the new array.
  * **Non-Synchronized:** `ArrayList` is **not thread-safe**. If multiple threads access it concurrently, it must be synchronized externally (e.g., using `Collections.synchronizedList`).

### 2\. Performance and Use Cases ðŸš€

The performance of `ArrayList` operations is directly related to its array-backed nature:

| Operation | Time Complexity (Big O) | Rationale |
| :--- | :--- | :--- |
| **`get(index)`** | $O(1)$ (Constant Time) | Direct access by index in an array is instant. |
| **`add()`** (at end) | $O(1)$ (Average) | Usually constant time, but $O(n)$ when resizing is required. |
| **`add(index, E e)`** | $O(n)$ (Linear Time) | Inserting in the middle requires shifting all subsequent elements. |
| **`remove(index)`** | $O(n)$ (Linear Time) | Removing requires shifting all subsequent elements to fill the gap. |

**Best Used When:** You need **fast random access** (`get()`) and your application involves **more reading** than inserting/deleting in the middle.

### 3\. Implementation and Example

#### Declaration and Initialization

```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListDemo {
    public static void main(String[] args) {
        // 1. Declare using the List interface (recommended practice)
        List<String> names = new ArrayList<>(); 
        
        // 2. Add elements
        names.add("Bob");        // Index 0
        names.add("Alice");      // Index 1
        names.add(1, "Charlie"); // Insert at index 1, shifting Alice to index 2
        
        System.out.println("List after insertion: " + names); 
        // Output: [Bob, Charlie, Alice]
        
        // 3. Access elements (O(1))
        String first = names.get(0);
        System.out.println("First element: " + first); // Output: Bob
        
        // 4. Remove elements (O(n))
        names.remove("Bob"); // Removes by object value
        
        // 5. Check size and iterate
        System.out.println("Size: " + names.size()); // Output: 2
        
        // Standard iteration
        for (String name : names) {
            System.out.println("Name: " + name);
        }
    }
}
```

### 4\. `ArrayList` vs. `LinkedList`

It's useful to compare `ArrayList` to its main alternative, `LinkedList`, which also implements the `List` interface.

| Feature | `ArrayList` | `LinkedList` |
| :--- | :--- | :--- |
| **Internal Structure** | Resizable Array | Doubly Linked List (nodes with references) |
| **Access Time (`get`)** | **Very Fast** ($O(1)$) | Slow ($O(n)$ - must traverse from the start/end) |
| **Insertion/Deletion** | Slow in the middle ($O(n)$ - requires shifting) | **Very Fast** ($O(1)$ - only requires changing pointers) |
| **Memory Overhead** | Lower, just the array overhead. | Higher, each element requires extra memory for two pointers (next and previous). |
| **Use Case** | Read-heavy applications, fast index access. | Write-heavy applications, frequent additions/removals at the beginning/middle. |

