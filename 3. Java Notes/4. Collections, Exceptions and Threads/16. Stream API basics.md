# ðŸ”— Collections, Exceptions, Concurrency

## 16\. Stream API Basics

The **Stream API** (introduced in Java 8) provides a powerful, functional, and declarative way to process sequences of elements from collections, arrays, or I/O channels. Unlike collections, streams don't store data; they **process** data on demand.

### 1\. Stream Characteristics and Philosophy ðŸŒŠ

1.  **Functional:** Operations are expressed using lambda expressions (e.g., `filter`, `map`).
2.  **Declarative:** You define *what* you want to do (filter the even numbers), not *how* to do it (explicitly looping and checking an `if` condition).
3.  **Pipeline:** Stream operations are chained together to form a processing pipeline.
4.  **Immutability:** Streams do not modify the original data source; they produce a new stream or a final result.
5.  **Lazy Evaluation:** Operations are only executed when a terminal operation is called.

### 2\. The Three Stages of a Stream Pipeline

A stream pipeline consists of three parts demonstrated in your example:

| Stage | Description | Example Code | Result Type |
| :--- | :--- | :--- | :--- |
| **1. Source** | The collection, array, or generator from which the stream originates. | `nums.stream()` or `nums.parallelStream()` | `Stream<T>` |
| **2. Intermediate Operations** | Operations that transform the stream and return a *new* stream. These are **lazy**; they don't execute until Stage 3. | `.filter(n -> n%2 == 0)` and `.sorted()` | `Stream<T>` |
| **3. Terminal Operation** | An operation that consumes the stream, produces a final result (like a count or a single value), or causes a side effect (like printing). This operation **triggers** execution. | `.forEach(n -> System.out.println(n))` | `void` or a final value |

-----

### 3\. Creating a Stream (Source)

Your example demonstrates the two primary ways to create a stream from a `Collection`:

```java
List<Integer> nums = Arrays.asList(4, 5, 7, 3, 2, 6);

// Normal Stream: Processes elements sequentially in a single thread.
Stream<Integer> sequentialStream = nums.stream(); 

// Parallel Stream: Processes elements concurrently across multiple threads.
Stream<Integer> parallelStream = nums.parallelStream(); 
```

### 4\. Intermediate Operations and Functional Interfaces

Intermediate operations rely on the functional interfaces introduced previously (Section 13). Your commented-out code perfectly illustrates the concise power of lambdas vs. verbose traditional interfaces:

#### A. `filter()` (Uses `Predicate<T>`)

The `filter` operation takes a **`Predicate`** (a function that returns a boolean) and includes elements that satisfy the condition.

| Traditional Approach | Stream API Approach |
| :--- | :--- |
| **Traditional (Verbose):** <br> `Predicate<Integer> p = new Predicate<Integer>() { public boolean test(Integer n) { return n%2==0; } };` | **Lambda (Concise):** <br> `filter(n -> n % 2 == 0)` |

**Action in Example:** Filters the list `[4, 5, 7, 3, 2, 6]` down to `[4, 2, 6]`.

#### B. `map()` (Uses `Function<T, R>`)

The `map` operation takes a **`Function`** (a function that transforms an input into an output) and applies it to every element.

| Traditional Approach | Stream API Approach |
| :--- | :--- |
| **Traditional (Verbose):** <br> `Function<Integer, Integer> fun = new Function<Integer,Integer>() { public Integer apply(Integer n) { return n*2; } };` | **Lambda (Concise):** <br> `map(n -> n * 2)` |

**Action in Example:** If used on the filtered result `[4, 2, 6]`, it transforms the stream to `[8, 4, 12]`.

#### C. `sorted()`

The `sorted()` operation returns a stream consisting of the elements of the current stream, sorted according to natural order (or a custom `Comparator`).

**Action in Example:** Sorts the filtered stream `[4, 2, 6]` into `[2, 4, 6]`.

### 5\. Terminal Operations

#### A. `forEach()`

The `forEach` operation is a common terminal operation that consumes the elements of the stream and performs an action (defined by a **`Consumer`**) on each element. It does not return a value.

```java
// Terminal operation that executes the entire pipeline
sortedValues.forEach(n -> System.out.println(n)); 
```

**Output of Final Code Block:**

```
2
4
6
```

#### B. `reduce()`

The `reduce` operation combines the elements of a stream into a single result (e.g., sum, maximum, product).

```java
int result = nums.stream()
    .filter(n -> n % 2 == 0) // [4, 2, 6]
    .map(n -> n * 2)         // [8, 4, 12]
    .reduce(0, (c, e) -> c + e); // c=current sum, e=element
    // Initial value (0) + 8 + 4 + 12 = 24
System.out.println(result); // Output: 24
```

