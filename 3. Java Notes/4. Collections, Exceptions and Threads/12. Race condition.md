# ðŸ”— Collections, Exceptions, Concurrency

## 12\. Race Conditions and Synchronization

A **Race Condition** is a critical, subtle problem that occurs in concurrent programming when the outcome of a program depends on the unpredictable sequence or timing of events executed by multiple threads. It typically happens when **multiple threads access and try to modify shared data simultaneously**.

### 1\. The Critical Section and Atomic Operations ðŸ’”

The core issue lies in operations that appear to be a single step but are actually composed of multiple low-level steps. This multi-step process is called a **Critical Section**.

In your `Counter` class, the simple line:

```java
// count++;
```

is NOT atomic (a single, indivisible operation) at the CPU level. It involves three steps:

1.  **Read:** Read the current value of `count` from shared memory (Heap).
2.  **Modify:** Increment the value (`count = count + 1`).
3.  **Write:** Write the new value back to shared memory.

If two threads execute this concurrently, they "race" to perform the steps, leading to data loss.

### 2\. Scenario 1: Race Condition (Unsynchronized Method)

When the `increment()` method is **NOT synchronized**, the threads can interleave their operations unpredictably.

#### Code Scenario (Uncommented `public void increment()`):

```java
// class Counter {
//     int count;
//     public void increment() { // UNSAFE
//         count++; 
//     }
// }
// ... (rest of Demo class)
```

#### Race Condition Example

Assume `count` is 100.

| Time | Thread 1 Action | Thread 2 Action | Shared `count` Value | Expected `count` |
| :--- | :--- | :--- | :--- | :--- |
| **T1** | **Reads** `count` (100) | | 100 | 101 (T1) |
| **T2** | | **Reads** `count` (100) | 100 | 101 (T2) |
| **T3** | Increments local value to 101 | | 100 | |
| **T4** | | Increments local value to 101 | 100 | |
| **T5** | **Writes** 101 to memory | | **101** | |
| **T6** | | **Writes** 101 to memory | **101** | **Should be 102** |

The increment operation from T2 is **lost**, resulting in a final count of 101 instead of the correct 102.

#### Expected Output (Unsynchronized Run)

Since each thread tries to increment 10,000 times, the mathematically correct final value should be $10,000 + 10,000 = 20,000$.

| Expected Calculation | Actual Typical Output | Reason |
| :--- | :--- | :--- |
| 20,000 | **19875** (or any value $< 20,000$) | **Race Condition** leads to lost updates due to threads overwriting each other's work. |

-----

### 3\. Scenario 2: Preventing Race Condition (Synchronized Method)

The **`synchronized`** keyword is Java's primary tool for solving race conditions by ensuring that only one thread can execute a critical section of code at a time.

#### How `synchronized` Works

When a method is declared `synchronized`:

1.  A thread attempting to execute it must first acquire the **monitor lock** (or mutex) associated with the object (`c` in your example).
2.  Once a thread holds the lock, no other thread can enter *any* synchronized method on the *same object*.
3.  When the thread exits the synchronized method (normally or via exception), the lock is released.

This creates **mutual exclusion**, guaranteeing that the Read-Modify-Write sequence for `count++` is completed by one thread before another thread can start it.

#### Code Scenario (Commented `public synchronized void increment()`):

```java
class Counter {
	int count;
	public synchronized void increment() { // SAFE
		count++;
	}
}
// ... (rest of Demo class)
```

#### Expected Output (Synchronized Run)

| Expected Calculation | Actual Typical Output | Reason |
| :--- | :--- | :--- |
| 20,000 | **20000** | **Synchronization** guarantees atomicity; one thread completes the `count++` operation fully before the other thread can start. |

### 4\. The `join()` Method

The code uses `t1.join()` and `t2.join()`, which is crucial for getting the correct final output.

  * **Purpose:** The `join()` method forces the calling thread (in this case, the **main thread**) to wait until the thread on which `join()` is called (e.g., `t1`) completes its execution.
  * **Necessity:** Without `join()`, the main thread would likely execute `System.out.println(c.count)` immediately after starting `t1` and `t2`, printing a value close to 0, long before the counting threads finished.

-----

### 5\. Scenario 3: `wait()` vs `join()`

If you removed the `join()` calls, the main thread would race with `t1` and `t2`.

#### Code Scenario (Removing `t1.join()` and `t2.join()`):

```java
// ...
t1.start();
t2.start();
// t1.join(); // Removed
// t2.join(); // Removed

System.out.println(c.count); // Executed almost immediately
// ...
```

#### Expected Output (Without `join()`):

