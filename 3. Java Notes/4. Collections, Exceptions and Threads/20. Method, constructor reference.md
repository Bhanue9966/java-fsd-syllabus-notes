# ðŸ”— Collections, Exceptions, Concurrency

## 20\. Method and Constructor References

**Method References** and **Constructor References** are syntactic sugar for Lambda Expressions. They allow you to refer to a method or a constructor by its name, making the code even more compact and readable, provided the method already exists.

The condition for using a reference is that the method/constructor's signature **must exactly match** the signature of the single abstract method in the target **Functional Interface**.

### 1\. Types of Method References ðŸŽ¯

There are four primary ways to use a method reference, depending on whether the method is static, instance-based, or part of a specific object.

| Type | Syntax | Example Lambda | Equivalent Reference | Purpose |
| :--- | :--- | :--- | :--- | :--- |
| **1. Static Method** | `ClassName::staticMethodName` | `(x) -> Math.sqrt(x)` | `Math::sqrt` | Refers to a static method of a class. |
| **2. Instance Method** (Specific Object) | `instanceName::instanceMethodName` | `(s) -> System.out.println(s)` | `System.out::println` | Refers to an instance method of an existing object. |
| **3. Instance Method** (Arbitrary Object) | `ClassName::instanceMethodName` | `(s) -> s.toUpperCase()` | `String::toUpperCase` | The first argument to the lambda becomes the instance on which the method is called. |
| **4. Constructor** | `ClassName::new` | `() -> new Employee()` | `Employee::new` | Refers to a class's constructor. |

### 2\. Detailed Examples

#### A. Static Method Reference

This is often used with Stream operations like `forEach` or `map` when the logic is handled by a utility method.

```java
import java.util.List;
import java.util.Arrays;

public class StaticReferenceDemo {
    
    public static void printItem(String s) {
        System.out.println("Item: " + s);
    }
    
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Anya", "Ben", "Carl");
        
        // Lambda: (name) -> StaticReferenceDemo.printItem(name)
        names.forEach(StaticReferenceDemo::printItem); 
        
        /* Output:
        Item: Anya
        Item: Ben
        Item: Carl
        */
    }
}
```

#### B. Instance Method Reference (Arbitrary Object)

This is very common in Stream API transformations where you call an instance method on the element being processed.

```java
List<String> data = Arrays.asList("alpha", "beta", "gamma");

// Lambda: (s) -> s.length()
// Functional Interface method: Integer apply(String s)
data.stream()
    .map(String::length) // Reference: String::length
    .forEach(System.out::println); 
    
/* Output:
5
4
5
*/
```

#### C. Constructor Reference

This allows you to create instances of a class using a functional interface, typically within the `map` or `collect` steps of a stream pipeline.

Assume a class `Employee(String name)` exists.

```java
import java.util.stream.Collectors;

// Functional Interface method: Employee apply(String name)
List<String> employeeNames = Arrays.asList("Anya", "Ben");

// Lambda: (name) -> new Employee(name)
List<Employee> employees = employeeNames.stream()
    .map(Employee::new) // Reference: Employee::new
    .collect(Collectors.toList());
```

### 3\. Key Benefit

The main advantage of using Method References over Lambda Expressions is **readability**. When the body of a lambda expression simply calls an existing method, the reference provides a highly concise and clear way to express that intent.

$$(\text{parameters}) \rightarrow \text{existingMethod}(\text{parameters}) \quad \text{becomes} \quad \text{ClassName}::\text{methodName}$$

