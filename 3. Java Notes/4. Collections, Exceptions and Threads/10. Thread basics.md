# ðŸ”— Collections, Exceptions, Concurrency

## 10\. Threads Basics

**Concurrency** is the ability of a program to execute multiple tasks or processes *at the same time* (concurrently). In Java, the fundamental unit of concurrency is the **Thread**.

### 1\. Process vs. Thread ðŸ§ 

It's crucial to distinguish between a Process and a Thread:

| Feature | Process | Thread |
| :--- | :--- | :--- |
| **Definition** | An independent program or application execution environment. | A single sequence of execution within a process. |
| **Resources** | Has its own separate memory space (Heap, Stack). | **Shares** the memory space (Heap) of its parent process. |
| **Communication**| Complex (requires IPC - Inter-Process Communication). | Easy (shared memory is accessible by all threads). |
| **Creation/Switching**| Heavyweight (slow to create and switch). | **Lightweight** (fast to create and switch). |

**Analogy:** A **Process** is like an entire running application (e.g., a web browser). A **Thread** is like a single tab within that browser, running a separate task (e.g., loading a video) but sharing the browser's overall resources.

### 2\. The Java Thread Model

Every Java application starts with a single thread, called the **main thread**. The JVM allows the program to create and run additional threads simultaneously.

### 3\. Creating a Thread (Two Ways)

There are two primary ways to define and execute the logic that a new thread will run:

#### A. Implementing the `Runnable` Interface

This is the preferred approach because it allows the class to inherit from another class (Java supports single class inheritance).

1.  **Implement `Runnable`:** Create a class that implements the `java.lang.Runnable` interface and define the task logic within the required `run()` method.
2.  **Create `Thread`:** Instantiate a `Thread` object, passing the `Runnable` object to its constructor.
3.  **Start:** Call the `start()` method on the `Thread` object.

<!-- end list -->

```java
// 1. Define the task logic
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            System.out.println("Runnable Thread: " + i);
        }
    }
}

public void runRunnable() {
    // 2. Wrap Runnable in a Thread
    Thread t1 = new Thread(new MyRunnable()); 
    // 3. Start the thread (calls run() internally on a new thread)
    t1.start(); 
}
```

#### B. Extending the `Thread` Class

1.  **Extend `Thread`:** Create a class that extends `java.lang.Thread`.
2.  **Override `run()`:** Place the thread's execution logic inside the overridden `run()` method.
3.  **Start:** Instantiate the subclass and call the `start()` method.

<!-- end list -->

```java
// 1. Define the task logic and thread
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            System.out.println("Extends Thread: " + i);
        }
    }
}

public void runThread() {
    // 2. Instantiate and start
    MyThread t2 = new MyThread();
    // 3. Start the thread
    t2.start(); 
}
```

### 4\. The Critical Distinction: `start()` vs. `run()`

  * **`start()`:** **Creates a new thread** of execution, and the JVM calls the `run()` method on that new thread. This is the correct way to begin parallel execution.
  * **`run()`:** Executes the code inside the method, but in the **same thread** that called it. If you call `t.run()`, no new thread is created, and the task executes sequentially like a normal method call.

### 5\. Thread Execution Order

The JVM and the operating system's thread scheduler determine when and for how long each thread runs. The sequence of execution is **non-deterministic** (unpredictable).

In the execution of `runRunnable()` and `runThread()`, the output lines will likely be interleaved, demonstrating true concurrent execution.

