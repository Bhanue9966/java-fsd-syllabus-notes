# ðŸ”— Collections, Exceptions, Concurrency

## 14\. Lambda Expressions

A **Lambda Expression** is a concise, anonymous function (a method without a name) that can be passed around as an object. It provides a clean way to implement the single abstract method of a **Functional Interface**.

Lambda expressions drastically reduce boilerplate code, especially when dealing with functional interfaces like `Runnable`, `Comparator`, and the interfaces in `java.util.function`.

### 1\. The Structure of a Lambda Expression

A lambda expression consists of three parts:

$$\text{Lambda Expression} = \underbrace{(\text{parameters})}_{\text{Input}} \rightarrow \underbrace{\{\text{body}\}}_{\text{Operation}}$$

1.  **Parameters:** A comma-separated list of formal parameters, enclosed in parentheses (if zero or more than one parameter).
2.  **Arrow Token (`->`):** Connects the parameters to the body.
3.  **Body:** The main logic of the function, which can be a single expression or a block of statements.

### 2\. Syntax Examples and Simplifications

The syntax of a lambda expression can be simplified based on the number of parameters and the complexity of the body.

| Feature | Standard Syntax | Simplified Syntax | Rule |
| :--- | :--- | :--- | :--- |
| **No Parameters** | `() -> { System.out.println("Hello"); }` | `() -> System.out.println("Hello")` | Empty parentheses are mandatory. |
| **One Parameter** | `(String s) -> { return s.length(); }` | `s -> s.length()` | Parentheses around parameter and `return`/braces can be omitted. |
| **Multiple Parameters** | `(int a, int b) -> a + b` | `(a, b) -> a + b` | Parentheses around parameters are mandatory. Type inference is used. |
| **Block Body** | `s -> { System.out.print(s); return s.toUpperCase(); }` | N/A | Must use curly braces and explicit `return` if the body contains multiple statements. |

### 3\. Lambda Expression and Functional Interface Implementation

The compiler determines the parameter types and the return type of the lambda expression by matching it to the **signature of the single abstract method** in the target functional interface.

#### Example 1: Implementing `Runnable` (No Args, No Return)

**Before Lambda (Anonymous Inner Class):**

```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Task running.");
    }
});
```

**After Lambda:**

```java
// Runnable's abstract method: void run()
Thread t = new Thread(() -> System.out.println("Task running."));
```

#### Example 2: Implementing `Comparator` (Two Args, Returns Int)

**Before Lambda:**

```java
Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b); 
    }
});
```

**After Lambda (Using Type Inference):**

```java
// Comparator's abstract method: int compare(T o1, T o2)
Collections.sort(names, (a, b) -> a.compareTo(b));
```

### 4\. Lambda Scope (Variable Capture) ðŸ”Ž

Lambda expressions can access variables defined in their enclosing scope, a concept known as **closure**.

  * **Instance/Static Variables:** Lambdas can read and modify instance variables and static variables just like an anonymous inner class.
  * **Local Variables:** Lambdas can only read **local variables** that are **effectively final**.
      * **Effectively Final:** A local variable that is not explicitly declared `final` but whose value is never changed after its initialization. If you try to reassign a local variable that is used inside a lambda, the compiler will throw an error.

<!-- end list -->

```java
public class LambdaScope {
    int instanceVar = 10;
    
    public void execute() {
        int localVar = 20; // This is effectively final
        // localVar = 21; // Error if uncommented, as it breaks the effectively final rule

        Runnable r = () -> {
            System.out.println(instanceVar); // OK (accesses instance variable)
            System.out.println(localVar);    // OK (reads effectively final local variable)
            // localVar++; // ERROR (cannot modify local variable)
        };
        new Thread(r).start();
    }
}
```
