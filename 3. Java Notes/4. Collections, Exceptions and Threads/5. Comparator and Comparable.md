# ðŸ”— Collections, Exceptions, Concurrency

## 5\. Comparator and Comparable

In Java, when you store custom objects (like a `Student` or `Employee` class) in a collection, you often need to sort them. Since the JVM doesn't know *how* to compare two custom objects, you must define the sorting criteria using one of two interfaces: **`Comparable`** or **`Comparator`**.

### 1\. The `Comparable` Interface (Internal Sorting)

The `Comparable` interface is used to define an object's **natural ordering**â€”the standard way that object type should be sorted.

  * **Location:** Implemented by the **class itself**.
  * **Method:** It requires implementing the single method:
    $$\text{public int compareTo(T obj)}$$
  * **Result:** The method returns an `int` value:
      * **Negative (e.g., -1):** `this` object is **less than** `obj`.
      * **Zero (0):** `this` object is **equal to** `obj`.
      * **Positive (e.g., 1):** `this` object is **greater than** `obj`.
  * **Use Case:** Use when you need a single, consistent, default way to sort the objects (e.g., always sort employees by ID).
  * **Usage:** Collections that sort elements automatically (like `TreeSet` or `TreeMap`) and the utility method `Collections.sort(List)` use this interface by default.

#### Example: Sorting a `Person` by Age (Natural Ordering)

```java
import java.util.*;

class Person implements Comparable<Person> {
    String name;
    int age;
    
    // Constructor...
    
    @Override
    public int compareTo(Person other) {
        // Defines natural order as sorting by Age (ascending)
        if (this.age == other.age) return 0;
        return this.age > other.age ? 1 : -1;
        
        // Simpler way: return this.age - other.age; 
    }
}
// Usage: Collections.sort(listOfPeople); // sorts by age
```

-----

### 2\. The `Comparator` Interface (External Sorting)

The `Comparator` interface is used to define **external sorting logic**â€”a separate, external way to sort objects, typically used when you need multiple sorting options (e.g., sort employees by Name, then by Salary, then by Hire Date).

  * **Location:** Implemented by a **separate class** (or using Lambda expressions in modern Java).
  * **Method:** It requires implementing the single method:
    $$\text{public int compare(T obj1, T obj2)}$$
  * **Result:** It compares `obj1` to `obj2` and returns an `int` with the same meaning as `compareTo()`.
  * **Use Case:** Use when you need **multiple, flexible sorting criteria** for the same object type.

#### Example: Sorting a `Person` by Name (External Ordering)

```java
import java.util.Comparator;

// Separate class to define sorting by name
class NameComparator implements Comparator<Person> {
    
    @Override
    public int compare(Person p1, Person p2) {
        // Uses String's built-in compareTo method to sort by name alphabetically
        return p1.name.compareTo(p2.name); 
    }
}

// Usage in main method:
// Collections.sort(listOfPeople, new NameComparator()); // sorts by name
```

### 3\. Key Differences and Relationship

| Feature | `Comparable` | `Comparator` |
| :--- | :--- | :--- |
| **Location** | Implemented **inside** the class (modifies the class). | Implemented in a **separate class**. |
| **Method** | `compareTo(T obj)` | `compare(T obj1, T obj2)` |
| **Sorting** | Defines **natural ordering** (single default sort). | Defines **custom ordering** (multiple flexible sorts). |
| **Package** | `java.lang` (No import needed). | `java.util` (Requires import). |
| **Object Modification** | Modifies the class itself. | Does not modify the class; logic is external. |

**Relationship:** If a class does **not** implement `Comparable` (or you need a different sort), you must provide a `Comparator` to sort its objects.

