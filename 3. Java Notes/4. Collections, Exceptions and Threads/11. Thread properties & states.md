# ðŸ”— Collections, Exceptions, Concurrency

## 11. Thread Properties and States (Life Cycle)

Every thread in Java goes through a cycle of states from the moment it's created until it completes its execution. Understanding this **Thread Life Cycle** is crucial for writing correct, efficient concurrent programs.


### 1. Thread Life Cycle States

The diagram illustrates the primary states a thread can be in:

![Thread lifecycle](<Thread lifecycle.png>)

#### A. ðŸŸ¢ New
* **Definition:** The thread has been created (`new Thread()`) but has not yet started execution.
* **State:** The thread object exists, but it is not yet active.
* **Transition:** The only event that can move a thread from **New** to **Runnable** is calling the **`start()`** method.

#### B. ðŸ”µ Runnable
* **Definition:** The thread is ready to execute and waiting for the CPU time (waiting to be scheduled).
* **State:** The thread may or may not be currently executing, but it is in the queue to be picked up by the thread scheduler. It is considered "alive."
* **Transition:**
    * **New â†’ Runnable:** When the `start()` method is called.
    * **Blocked/Waiting/Sleeping â†’ Runnable:** When the wait time is up, a notification is received, or an I/O operation completes.

#### C. ðŸŸ¢ Running
* **Definition:** The thread is currently executing on the CPU.
* **State:** This is the thread that holds the processor.
* **Transition:**
    * **Runnable â†’ Running:** The thread scheduler selects the thread from the Runnable pool.
    * **Running â†’ Runnable:** The thread scheduler temporarily preempts the thread (time-slicing), or the thread voluntarily calls **`yield()`**.
    * **Running â†’ Blocked/Waiting/Sleeping:** The thread calls methods like `wait()`, `sleep()`, or performs a blocking I/O operation.

#### D. ðŸ”´ Blocked / Waiting / Sleeping
* **Definition:** The thread is temporarily inactive and cannot run, even if the processor is available.
* **State:** The thread is still alive but is temporarily ineligible for execution.
* **Causes (as per the diagram):**
    * **`sleep(time)`:** The thread is suspended for a specified duration.
    * **`wait()`:** The thread releases the object's lock and enters the waiting pool, usually waiting for another thread to call `notify()` or `notifyAll()`.
    * **Blocking I/O:** The thread is waiting for an I/O operation (like disk read or network response) to complete.
* **Transition:**
    * **Blocked/Waiting/Sleeping â†’ Runnable:** When the specified `sleep` time is up, the `notify()` or `notifyAll()` method is called, or the blocked resource becomes available.

#### E. ðŸ”µ Dead
* **Definition:** The thread has completed its execution.
* **State:** The thread object is no longer active.
* **Transition:**
    * **Running â†’ Dead:** The `run()` method completes normally, or the thread exits due to an unhandled exception.
* **Finality:** Once a thread enters the Dead state, it **cannot** be restarted. Calling `start()` on a dead thread will throw an `IllegalThreadStateException`.

---

### 2. Thread Properties

In addition to its state, every thread has three key properties that can be inspected or modified:

#### A. Name
* **Purpose:** Useful for debugging and logging concurrent applications. The main thread is named `"main"`, and user threads are named sequentially (`"Thread-0"`, `"Thread-1"`, etc.) by default.
* **Methods:**
    * `getName()`: Retrieves the thread's name.
    * `setName(String name)`: Sets a new name.

#### B. Priority
* **Range:** An integer value from 1 (lowest priority) to 10 (highest priority). **`NORM_PRIORITY`** (5) is the default.
* **Effect:** Priority is a **hint** to the thread scheduler. Higher priority threads are *generally* given preference over lower priority threads, but this behavior is highly dependent on the underlying operating system and the JVM implementation.
* **Methods:**
    * `getPriority()`: Retrieves the current priority.
    * `setPriority(int newPriority)`: Sets the priority.

#### C. Daemon Status
* **Definition:** A thread can be marked as a **Daemon thread**.
* **Characteristics:** Daemon threads are background threads (e.g., Garbage Collector, finalizer) that run to serve user threads. The JVM will **not wait** for Daemon threads to finish before exiting.
* **Rule:** If the only remaining running threads are Daemon threads, the JVM will terminate the program.
* **Methods:**
    * `isDaemon()`: Checks if the thread is a Daemon thread.
    * `setDaemon(true)`: Marks the thread as a Daemon thread (must be called *before* `start()`).

