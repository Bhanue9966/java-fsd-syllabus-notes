# üîó Collections, Exceptions, Concurrency

## 13\. Functional Programming

**Functional Programming (FP)** is a programming paradigm that treats computation as the evaluation of mathematical **functions** and avoids changing **state** and **mutable data**. Java introduced FP concepts primarily with the advent of **Lambda Expressions** in Java 8.

### 1\. Core Principles of Functional Programming üéØ

#### A. Immutability

  * **Principle:** Data objects should not be changed after they are created. If you need to "modify" data, you create a new data object instead.
  * **Java Context:** Promotes the use of final variables and immutable objects (like `String`). This is vital for concurrency, as it eliminates race conditions caused by shared mutable state.

#### B. Purity (Pure Functions)

  * **Principle:** A **pure function** must satisfy two conditions:
    1.  It always produces the **same output** given the same inputs (referential transparency).
    2.  It produces **no side effects** (it doesn't modify external state, global variables, I/O, or mutable arguments).
  * **Benefit:** Pure functions are easy to test, compose, and parallelize.

| Feature | Pure Function | Impure Function |
| :--- | :--- | :--- |
| **Input $\rightarrow$ Output** | Always the same output for the same input. | Output can vary (e.g., depends on a global variable or system time). |
| **Side Effects** | None (no changes to the external world). | Modifies external state (e.g., updates a database, prints to console). |

#### C. Higher-Order Functions

  * **Principle:** Functions can be treated as **first-class citizens**‚Äîmeaning they can be passed as arguments to other functions, returned as values from other functions, or assigned to variables.
  * **Java Context:** Achieved using **functional interfaces** and **lambda expressions**, which represent blocks of code that can be passed around.

#### D. Declarative Style

  * **Principle:** Focus on **what** you want to achieve, rather than **how** to achieve it.
  * **Contrast:**
      * **Imperative (OOP/Looping):** Tells the computer *step-by-step* how to get the result (e.g., using `for` loops, if-else statements).
      * **Declarative (FP/Streams):** Describes the *desired result* (e.g., "filter this list, then map the result, then collect it").

### 2\. Functional Interfaces ü§ù

A **Functional Interface** is any interface that contains **exactly one abstract method**.

  * **Purpose:** They act as a contract for lambda expressions. A lambda expression provides the implementation for that single abstract method.
  * **Annotation:** They are often annotated with `@FunctionalInterface` (though not required), which tells the compiler to enforce the single abstract method rule.

#### Java's Built-in Functional Interfaces (The `java.util.function` Package)

| Interface | Abstract Method | Description |
| :--- | :--- | :--- |
| **`Predicate<T>`** | `boolean test(T t)` | Represents a boolean-valued function of one argument. Used for filtering. |
| **`Consumer<T>`** | `void accept(T t)` | Represents an operation that accepts a single input argument and returns no result. Used for actions (e.g., printing). |
| **`Function<T, R>`** | `R apply(T t)` | Represents a function that accepts one argument of type $T$ and produces a result of type $R$. Used for transformation (mapping). |
| **`Supplier<T>`** | `T get()` | Represents a supplier of results. Takes no arguments and returns a result of type $T$. Used for lazy initialization. |

```java
import java.util.function.Predicate;

public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        // Predicate (Functional Interface) implemented using a Lambda Expression
        Predicate<Integer> isEven = (num) -> num % 2 == 0;
        
        System.out.println("Is 10 even? " + isEven.test(10)); // true
    }
}
```

