# ðŸ”— Collections, Exceptions, Concurrency

## 7\. Exception Hierarchy and Custom Exceptions

### 1\. The Exception Hierarchy ðŸŒ²

All exceptions and errors in Java are derived from the root class, **`java.lang.Throwable`**. The hierarchy divides errors into two main categories: **Checked** and **Unchecked** exceptions, which dictates whether the compiler forces you to handle them.

#### A. Checked Exceptions (Compiler Forces Handling)

  * **Definition:** Exceptions that are subclasses of `Exception` but **not** subclasses of `RuntimeException`.
  * **Requirement:** The Java compiler **forces** you to either handle these exceptions using a `try-catch` block or declare them using the `throws` keyword in the method signature.
  * **Occurrence:** Occur due to external circumstances that the program cannot control, but should anticipate (e.g., file not found, I/O errors, SQL errors).

| Example | Description | Handling |
| :--- | :--- | :--- |
| `IOException` | Failure in reading/writing files. | **Mandatory** |
| `SQLException` | Errors during database operations. | **Mandatory** |
| `ClassNotFoundException` | Class file not found at runtime. | **Mandatory** |

#### B. Unchecked Exceptions (No Mandatory Handling)

  * **Definition:** Exceptions that are subclasses of **`java.lang.RuntimeException`** or **`java.lang.Error`**.
  * **Requirement:** Handling is **optional**. They are usually programming mistakes and the compiler does not force handling.
  * **Occurrence:** Occur due to logical programming errors or invalid operations (e.g., trying to access an invalid index).

| Example | Description | Handling |
| :--- | :--- | :--- |
| `NullPointerException` | Trying to use a reference variable that points to `null`. | Optional (Fix the bug\!) |
| `ArrayIndexOutOfBoundsException` | Accessing an array with an illegal index. | Optional (Fix the bug\!) |
| `ArithmeticException` | Division by zero. | Optional (Fix the bug\!) |

-----

### 2\. Creating Custom (User-Defined) Exceptions

You can define your own exception classes to handle domain-specific errors gracefully, improving the clarity and robustness of your application's error reporting.

#### A. Steps to Create a Custom Exception

1.  **Define the Class:** Create a new class that extends either `Exception` (for a **Checked** custom exception) or `RuntimeException` (for an **Unchecked** custom exception).
2.  **Add Constructors:** Provide constructors, usually matching the standard exception constructors, which call the superclass constructor (`super(...)`) to pass the error message.

#### B. Example Implementation

Let's create a **Checked Exception** for an invalid withdrawal amount in a banking system.

```java
// 1. Create a Custom Checked Exception (extends Exception)
public class InsufficientFundsException extends Exception {
    
    // 2. Constructor to pass a custom message
    public InsufficientFundsException(String message) {
        super(message);
    }
}

// 3. Usage in an application method
public class BankAccount {
    private double balance = 1000;

    public void withdraw(double amount) 
        throws InsufficientFundsException { // Must declare the Checked Exception

        if (balance < amount) {
            // Throwing an instance of our custom exception
            throw new InsufficientFundsException("Withdrawal amount " + amount + 
                                                 " exceeds current balance " + balance);
        }
        balance -= amount;
        System.out.println("Withdrawal successful. New balance: " + balance);
    }
}

// 4. Client Code (must handle the checked exception)
public class Client {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        try {
            account.withdraw(1500); // This will throw InsufficientFundsException
        } catch (InsufficientFundsException e) {
            System.err.println("Transaction Failed: " + e.getMessage());
        }
    }
}
```

