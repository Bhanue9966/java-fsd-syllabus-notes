# ðŸ”— Collections, Exceptions, Concurrency

## 3\. Set

The **`Set`** interface models the mathematical concept of a set: a collection that **cannot contain duplicate elements**. It is a crucial part of the Java Collections Framework for data integrity and uniqueness checks.

### 1\. Key Characteristics of `Set`

  * **Uniqueness:** Guarantees that every element in the set is unique. If you try to add a duplicate element, the `add()` method returns `false` and the set remains unchanged.
  * **No Indexing:** Elements are **not ordered** by index, and access is not possible using `get(index)`. The exception is `LinkedHashSet`, which maintains insertion order.
  * **Equality Check:** `Set` implementations use the **`equals()`** method to check for duplicates. If you store custom objects in a `Set`, you **must override both `equals()` and `hashCode()`** to ensure uniqueness is determined by content, not memory address.

### 2\. Primary Implementations

The three main implementations of the `Set` interface offer different trade-offs in terms of speed, order, and sorting.

| Implementation | Internal Structure | Ordering | Performance | Use Case |
| :--- | :--- | :--- | :--- | :--- |
| **`HashSet`** | Hash Table (using a `HashMap`) | **No guaranteed order** (chaotic) | **Fastest** ($O(1)$) for basic operations (`add`, `remove`, `contains`). | High-speed uniqueness checks and storage. |
| **`LinkedHashSet`** | Hash Table + Doubly Linked List | **Insertion order** (elements retrieved in the order they were added). | Slightly slower than `HashSet`. | Need fast uniqueness checks while preserving insertion order. |
| **`TreeSet`** | Red-Black Tree (Balanced BST) | **Natural Sorted Order** (alphabetical, numerical) or custom order via `Comparator`. | Slower ($O(\log n)$) for basic operations. | Need a sorted set of unique elements. |

### 3\. Implementation and Example

We will use the most common implementation, `HashSet`, to demonstrate uniqueness.

#### Example: `HashSet` (Unordered, Unique)

```java
import java.util.HashSet;
import java.util.Set;

public class HashSetDemo {
    public static void main(String[] args) {
        // 1. Declare using the Set interface
        Set<String> fruitBasket = new HashSet<>();
        
        // 2. Add elements
        fruitBasket.add("Apple"); 
        fruitBasket.add("Banana");
        
        // 3. Attempt to add a duplicate
        boolean addedDuplicate = fruitBasket.add("Apple"); 

        System.out.println("Set: " + fruitBasket); 
        // Output: [Banana, Apple] (Order may vary, size is 2)
        
        System.out.println("Was duplicate added? " + addedDuplicate); 
        // Output: false (The size remains 2)
        
        // 4. Checking existence
        System.out.println("Contains Grape? " + fruitBasket.contains("Grape")); // false
        
        // 5. Iteration (Note: you cannot use a standard for-loop with index)
        for (String fruit : fruitBasket) {
            System.out.println("Item: " + fruit);
        }
    }
}
```

### 4\. Implementation Detail: Custom Objects and Hashing ðŸ”‘

If you store custom objects in a `HashSet` or `LinkedHashSet`, failing to override **`hashCode()`** and **`equals()`** will lead to incorrect behavior.

```java
class Item {
    int id;
    String name;
    
    // Constructor...
    
    // Without overriding equals() and hashCode(), two Item objects 
    // with id=1 will be considered DIFFERENT because their memory addresses differ.
    
    @Override // Crucial for Set to identify duplicates by content
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Item item = (Item) o;
        return id == item.id; // Equality based on ID value
    }

    @Override // Crucial for fast lookup in HashSet buckets
    public int hashCode() {
        return id; // Hash code based on the unique identifier (ID)
    }
}

// Set<Item> itemSet = new HashSet<>();
// itemSet.add(new Item(1, "Pen"));
// itemSet.add(new Item(1, "Pencil")); // This is now blocked as a duplicate if equals/hashCode are correct.
```

