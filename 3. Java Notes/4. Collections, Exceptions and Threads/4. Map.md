# ðŸ”— Collections, Exceptions, Concurrency

## 4\. Map

The **`Map`** interface is a core component of the Java Collections Framework, but it is **not** a descendant of the `Collection` interface. It represents a collection of elements organized as **key-value pairs**, where the key is used to look up the associated value.

### 1\. Key Characteristics of `Map`

  * **Key Uniqueness:** Every **key** in a Map must be **unique**. If you attempt to insert a key that already exists, the new value will **overwrite** the old value.
  * **No Order Guarantee:** Like `Set`, `Map` implementations generally do not guarantee insertion order, but some specialized versions do (e.g., `LinkedHashMap`).
  * **Key Lookup:** Operations are typically very fast because they rely on hashing (like `HashSet`).
  * **Access:** Maps cannot be traversed directly using an `Iterator` because they are not part of the `Collection` interface. You must access keys or values first.

### 2\. Primary Implementations

The three main `Map` implementations parallel those of the `Set` interface, offering different ordering and performance characteristics.

| Implementation | Internal Structure | Ordering | Performance | Use Case |
| :--- | :--- | :--- | :--- | :--- |
| **`HashMap`** | Hash Table | **No guaranteed order** (chaotic) | **Fastest** ($O(1)$) for basic operations (`put`, `get`, `containsKey`). | High-speed key-value mapping where order doesn't matter. |
| **`LinkedHashMap`** | Hash Table + Doubly Linked List | **Insertion order** (keys retrieved in the order they were added). | Slightly slower than `HashMap`. | Need fast key lookup while preserving insertion order. |
| **`TreeMap`** | Red-Black Tree (Balanced BST) | **Natural Sorted Key Order** (alphabetical, numerical) or custom order via `Comparator`. | Slower ($O(\log n)$) for basic operations. | Need a sorted set of key-value pairs. |

### 3\. Implementation and Example: `HashMap`

We'll use the most common implementation, `HashMap`, to demonstrate basic operations.

#### Example: `HashMap` (Unordered Key-Value Pairs)

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapDemo {
    public static void main(String[] args) {
        // Map stores Integer keys and String values
        Map<Integer, String> employeeMap = new HashMap<>();
        
        // 1. Adding elements (put)
        employeeMap.put(1001, "Alice");
        employeeMap.put(1002, "Bob");
        employeeMap.put(1003, "Charlie");
        
        // 2. Overwriting a value (keys must be unique)
        employeeMap.put(1001, "Alice Smith"); 

        // 3. Getting a value (get)
        String employeeName = employeeMap.get(1002);
        System.out.println("Employee 1002: " + employeeName); // Output: Bob

        // 4. Check size and key existence
        System.out.println("Total entries: " + employeeMap.size()); // Output: 3
        System.out.println("Contains key 1003? " + employeeMap.containsKey(1003)); // Output: true
    }
}
```

### 4\. Accessing Map Data (Traversal)

Since `Map` is not a `Collection`, you cannot iterate over it directly. Instead, you use specialized methods to get a view of its contents as a `Set` or `Collection`.

| Traversal Method | Returns | Description |
| :--- | :--- | :--- |
| **`keySet()`** | `Set<K>` | Returns a `Set` of all the keys in the map. |
| **`values()`** | `Collection<V>` | Returns a `Collection` of all the values in the map. |
| **`entrySet()`** | `Set<Map.Entry<K, V>>` | Returns a `Set` of key-value pairs (the most efficient way to iterate). |

#### Example: Iterating using `entrySet()`

```java
// Using the employeeMap from the previous example:

// Get the set of key-value pairs
for (Map.Entry<Integer, String> entry : employeeMap.entrySet()) {
    System.out.println("ID: " + entry.getKey() + ", Name: " + entry.getValue());
}
```

### 5\. Custom Keys and Hashing

Similar to `Set`, if you use a custom object as a **key** in a `HashMap` or `LinkedHashMap`, you **must override both `equals()` and `hashCode()`**.

  * The `Map` uses the key's hash code to find the correct internal "bucket" quickly ($O(1)$). If the hash code contract is broken, the map will fail to retrieve values correctly, even if the keys are logically equal.

