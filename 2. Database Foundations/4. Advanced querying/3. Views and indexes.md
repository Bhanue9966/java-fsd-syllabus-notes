## ðŸ’¾ Views and Indexes

This section covers two key database objects that do not store primary data but instead enhance data access, security, and query performance: **Views** (logical tables) and **Indexes** (performance structures).

-----

### 1\. Views

A **View** is a virtual table whose content is defined by a pre-written SQL query. It does not store data itself; rather, it dynamically generates its data when it is accessed, pulling the latest information from the underlying base tables.

#### A. Purpose of Views

  * **Security:** Restrict user access to specific rows or columns of a table without granting full access to the base table.
  * **Simplicity:** Simplify complex queries (e.g., multi-table joins) into a single, easy-to-query object.
  * **Consistency:** Present a consistent view of data even if the underlying schema changes (to some extent).

#### B. Creating a View

The `CREATE VIEW` command is used to define the view based on a `SELECT` statement.

```sql
-- Syntax
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM base_table(s)
WHERE condition;

-- Example: Creating a view that only shows non-sensitive public employee data
CREATE VIEW Vw_Public_Employee_Info AS
SELECT
    emp_id,
    first_name,
    last_name,
    dept_id
FROM Employees
WHERE status = 'Active';
```

#### C. Querying and Using a View

Once created, a view is queried just like a normal table.

```sql
-- Querying the view
SELECT first_name, last_name
FROM Vw_Public_Employee_Info
WHERE dept_id = 101;
```

#### D. Updating a View (`WITH CHECK OPTION`)

Views can sometimes be used for DML operations (`INSERT`, `UPDATE`, `DELETE`), but only if the view definition is simple (e.g., involves a single table and no aggregation).

The **`WITH CHECK OPTION`** clause prevents DML operations on the view that would result in rows disappearing from the view (i.e., data that violates the view's `WHERE` clause).

```sql
-- Example: Creating an updatable view with a check option
CREATE VIEW Vw_Sales_Salaries AS
SELECT emp_id, salary
FROM Employees
WHERE dept_id = 101
WITH CHECK OPTION;

-- This UPDATE works because the row remains in the view (dept_id is still 101)
UPDATE Vw_Sales_Salaries SET salary = 70000 WHERE emp_id = 5001;

-- This UPDATE would FAIL because it violates the view's WHERE clause
-- UPDATE Vw_Sales_Salaries SET dept_id = 102 WHERE emp_id = 5001;
```

#### E. Modifying and Dropping a View

  * **`ALTER VIEW`**: Used to change the definition of an existing view (supported in most major databases).
  * **`DROP VIEW`**: Permanently removes the view from the database.

<!-- end list -->

```sql
-- Modifying the view definition (e.g., adding the hire_date column)
ALTER VIEW Vw_Public_Employee_Info AS
SELECT
    emp_id,
    first_name,
    last_name,
    dept_id,
    hire_date
FROM Employees
WHERE status = 'Active';

-- Deleting the view
DROP VIEW Vw_Public_Employee_Info;
```

-----

### 2\. Indexes

An **Index** is a special lookup table that the database search engine can use to speed up data retrieval. Think of it like the index in the back of a textbook: instead of reading every page (full table scan), you can look up the topic quickly to find the exact page (row).

[Image of B-tree index structure]

#### A. Purpose and Trade-offs

  * **Performance:** Significantly speeds up `SELECT` queries that use the indexed column in the `WHERE` clause or `JOIN` conditions.
  * **Cost:** While indexes speed up reads, they slow down DML operations (`INSERT`, `UPDATE`, `DELETE`) because the index structure must be updated every time the underlying data changes. Use indexes strategically.

#### B. Types of Indexes

1.  **Primary Key Indexes:** Automatically created by the database when a **Primary Key** constraint is defined. These are usually **clustered** indexes (see below).
2.  **Unique Indexes:** Automatically created when a **UNIQUE** constraint is defined (but not as the Primary Key).
3.  **Non-Unique Indexes (B-tree):** The standard index created explicitly by the user on non-key columns to speed up searches.

##### Clustered vs. Non-Clustered Indexes (SQL Server/Oracle terminology)

  * **Clustered Index:** Defines the physical order in which the data is stored on disk. A table can only have **one** clustered index (usually the Primary Key).
  * **Non-Clustered Index:** Stores the logical ordering of the column and a pointer (row ID or clustered key) to the physical data location. A table can have many non-clustered indexes.

#### C. Creating an Index

The `CREATE INDEX` command is used to manually create a non-unique index on one or more columns.

```sql
-- Syntax (Non-Clustered/Standard Index)
CREATE [UNIQUE] INDEX index_name
ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);

-- Example 1: Indexing the last_name column for faster searching
CREATE INDEX idx_employee_lastname
ON Employees (last_name);

-- Example 2: Creating a composite index (for searches involving both columns)
CREATE INDEX idx_employee_dept_salary
ON Employees (dept_id, salary DESC);
```

#### D. Dropping an Index

Indexes can be removed using the `DROP INDEX` command when they are no longer beneficial or when their cost outweighs their performance gain.

```sql
-- Syntax (MySQL/PostgreSQL)
DROP INDEX index_name ON table_name;

-- Syntax (SQL Server/Oracle - uses schema qualification)
DROP INDEX table_name.index_name;

-- Example: Removing the index
DROP INDEX idx_employee_lastname ON Employees;
```