## ðŸ”— Standard Join Types

The four primary standard join types dictate exactly how data is combined from two tables, determining which rows are included in the result set based on whether a match exists.

![SQL joins](<../SQL images/SQL joins.jpg>)

-----

### 1\. INNER JOIN

The `INNER JOIN` (or simply `JOIN`) returns only the rows that have **matching values** in both tables. Any rows that do not have a match in the other table are excluded from the result.

  * **Principle:** Intersection of the two tables.
  * **Use Case:** Retrieving data only where a clear relationship exists (e.g., finding employees who are **actually assigned** to an existing department).

<!-- end list -->

```sql
SELECT
    E.first_name,
    D.dept_name
FROM
    Employees AS E
INNER JOIN -- Only matched rows from E and D
    Departments AS D
ON
    E.dept_id = D.dept_id;

-- Equivalent (pre-ANSI-92 syntax, less readable, generally avoided)
-- SELECT E.first_name, D.dept_name
-- FROM Employees E, Departments D
-- WHERE E.dept_id = D.dept_id;
```

-----

### 2\. LEFT OUTER JOIN

The `LEFT OUTER JOIN` (or simply `LEFT JOIN`) returns **all rows from the left table** (the first table named in the `FROM` clause) and the matched rows from the right table.

  * **Principle:** Left table plus the intersection.
  * If there is no match in the right table, the columns from the right table are filled with **`NULL`**.
  * **Use Case:** Finding all customers, even those who haven't placed an order yet.

<!-- end list -->

```sql
SELECT
    D.dept_name,
    E.first_name
FROM
    Departments AS D -- The LEFT table (All departments will be listed)
LEFT JOIN
    Employees AS E   -- The RIGHT table
ON
    D.dept_id = E.dept_id;

-- Result includes:
-- 1. All employees matched to their department.
-- 2. Any department that has *no* employees, with E.first_name appearing as NULL.
```

#### Finding Unmatched Records (Anti-Join)

A common and highly useful pattern is using a `LEFT JOIN` combined with a `WHERE` clause to find records in the left table that have **no match** in the right table.

```sql
-- Example: Find departments that currently have NO employees
SELECT
    D.dept_name
FROM
    Departments AS D
LEFT JOIN
    Employees AS E
ON
    D.dept_id = E.dept_id
WHERE
    E.emp_id IS NULL; -- The key condition for finding the "unmatched" rows
```

-----

### 3\. RIGHT OUTER JOIN

The `RIGHT OUTER JOIN` (or simply `RIGHT JOIN`) returns **all rows from the right table** (the second table named in the `FROM` clause) and the matched rows from the left table.

  * **Principle:** Right table plus the intersection.
  * If there is no match in the left table, the columns from the left table are filled with **`NULL`**.
  * **Note:** In practice, most developers use a `LEFT JOIN` and simply swap the table order to maintain consistency. A `RIGHT JOIN` is logically equivalent to reversing the tables and using a `LEFT JOIN`.

<!-- end list -->

```sql
SELECT
    E.first_name,
    D.dept_name
FROM
    Employees AS E   -- The LEFT table
RIGHT JOIN
    Departments AS D -- The RIGHT table (All departments will be listed)
ON
    E.dept_id = D.dept_id;

-- Result includes:
-- 1. All employees matched to their department.
-- 2. Any department that has *no* employees, with E.first_name appearing as NULL.
```

-----

### 4\. FULL OUTER JOIN

The `FULL OUTER JOIN` returns **all rows** when there is a match in either the left table or the right table. It is the union of the `LEFT JOIN` and `RIGHT JOIN` results.

  * **Principle:** The union of both tables (Left table, Right table, and the Intersection).
  * If a row has no match in the other table, the columns for the non-matching table are filled with **`NULL`**.
  * **Use Case:** Comparing two lists where you need to see all entries from both lists, matched where possible (e.g., comparing current customers with historical customers).

<!-- end list -->

```sql
SELECT
    A.column_a,
    B.column_b
FROM
    TableA AS A
FULL OUTER JOIN -- Returns all rows from A and all rows from B
    TableB AS B
ON
    A.match_id = B.match_id;
```

> **Note:** Some database systems, such as MySQL prior to version 8.0.35, do not explicitly support `FULL OUTER JOIN`. It must be simulated by combining a `LEFT JOIN` and a `RIGHT JOIN` using the **`UNION`** operator.
