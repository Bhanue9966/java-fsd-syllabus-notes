## ⚠️ PL/SQL Error Handling 

Error handling in PL/SQL involves trapping runtime errors (exceptions) and defining a course of action to resolve or gracefully manage them. This process prevents the entire program from terminating abruptly and ensures data integrity through controlled transaction management.

-----

### 1\. The `EXCEPTION` Section

The `EXCEPTION` section is the specialized part of the PL/SQL block that handles runtime errors. When an error occurs in the `BEGIN` section, execution immediately jumps to the `EXCEPTION` section. The process involves identifying the error and executing the corresponding handler.

```sql
DECLARE
    -- Declarations
BEGIN
    -- Executable statements
    -- If an error occurs here, control transfers to EXCEPTION
EXCEPTION
    WHEN exception_name THEN
        -- Handler for specific error
    WHEN OTHERS THEN
        -- Handler for all other errors
END;
/
```

### 2\. Predefined Exceptions

Oracle automatically defines and names several common runtime errors. These are the simplest to handle because you can reference them directly by name.

| Exception Name | Common Cause |
| :--- | :--- |
| **`NO_DATA_FOUND`** | A `SELECT INTO` statement returned zero rows. |
| **`TOO_MANY_ROWS`** | A `SELECT INTO` statement returned more than one row. |
| **`DUP_VAL_ON_INDEX`** | An `INSERT` or `UPDATE` attempts to create a duplicate value in a column covered by a **UNIQUE** index. |
| **`ZERO_DIVIDE`** | An attempt to divide a number by zero. |
| **`PROGRAM_ERROR`** | PL/SQL encounters an internal problem. |

```sql
DECLARE
    v_salary Employees.salary%TYPE;
BEGIN
    SELECT salary
    INTO v_salary
    FROM Employees
    WHERE emp_id = 9999; -- This ID doesn't exist

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Employee ID not found in the database.');
        v_salary := 0; -- Assign a default value
END;
/
```

-----

### 3\. User-Defined Exceptions

You can create and handle your own named exceptions for business-specific validation rules.

#### A. Declaration and Raising

1.  **Declare:** Define a variable of type `EXCEPTION` in the `DECLARE` section.
2.  **Raise:** Use the **`RAISE`** statement in the `BEGIN` section when a specific business condition is violated.

<!-- end list -->

```sql
DECLARE
    -- 1. Declare a custom exception
    e_low_commission_rate EXCEPTION;
    v_commission_rate     NUMBER(3, 2) := 0.05;
BEGIN
    IF v_commission_rate < 0.10 THEN
        -- 2. Raise the custom exception
        RAISE e_low_commission_rate;
    END IF;

EXCEPTION
    WHEN e_low_commission_rate THEN
        DBMS_OUTPUT.PUT_LINE('Alert: Commission rate is below the minimum threshold.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An unexpected system error occurred.');
END;
/
```

-----

### 4\. Catching All Errors (`OTHERS`)

The **`WHEN OTHERS`** handler is the generic error handler. It must be the **last handler** in the `EXCEPTION` section and is used to catch any error not covered by the preceding specific handlers.

#### A. Identifying Unknown Errors

Inside the `WHEN OTHERS` handler, you should use the following built-in functions to record or display the exact error that occurred:

  * **`SQLCODE`**: Returns the numeric error code (negative integer).
  * **`SQLERRM`**: Returns the corresponding error message (a character string).

<!-- end list -->

```sql
EXCEPTION
    WHEN TOO_MANY_ROWS THEN
        -- Specific handler
        DBMS_OUTPUT.PUT_LINE('Query returned too many rows.');
    WHEN OTHERS THEN
        -- Generic handler to catch all other errors
        DBMS_OUTPUT.PUT_LINE('Code: ' || SQLCODE);
        DBMS_OUTPUT.PUT_LINE('Message: ' || SQLERRM);
        -- Optionally, log the error details to an audit table
END;
/
```

-----

### 5\. Transaction Control in Error Handling

Error handling is incomplete without proper **Transaction Control Language (TCL)**. When a serious error occurs, you typically want to undo any DML operations that were performed within the failed transaction to maintain data consistency.

  * **`ROLLBACK`**: The most critical TCL command inside the `EXCEPTION` block. It undoes all uncommitted changes since the last `COMMIT` or transaction start.

<!-- end list -->

```sql
DECLARE
    e_invalid_id EXCEPTION;
BEGIN
    -- DML operation 1
    INSERT INTO LogTable (event) VALUES ('Starting transaction');

    -- DML operation 2 (Failure point)
    UPDATE Accounts SET balance = balance - 100 WHERE account_id = 'A1';

    IF SQL%ROWCOUNT = 0 THEN
        RAISE e_invalid_id;
    END IF;

    COMMIT;

EXCEPTION
    WHEN e_invalid_id THEN
        -- 1. Rollback the DML operation (A1 balance update and LogTable insert)
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Transaction failed. ID was invalid.');
    WHEN OTHERS THEN
        ROLLBACK; -- Critical step: undo any partial changes
        -- Log and re-raise or notify
        DBMS_OUTPUT.PUT_LINE('System error occurred. All changes reverted.');
END;
/
```