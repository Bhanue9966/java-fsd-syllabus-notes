## ðŸ’¾ Stored Program Units (01\_database\_foundations/02\_setup\_basics/20\_plsql\_program\_units.md)

Stored program units are named PL/SQL blocks that are compiled, stored in the database schema, and executed on demand. They provide essential features for code **reusability**, **security**, and **performance**.

-----

### 1\. Procedures

A **Procedure** is a named, reusable PL/SQL block designed to perform a specific action or task. Procedures do not typically return a value to the calling environment, though they can use `OUT` parameters to pass results back.

#### A. Creating a Procedure

The `CREATE OR REPLACE PROCEDURE` command is used, allowing you to rewrite the procedure without manually dropping the old version first.

```sql
CREATE OR REPLACE PROCEDURE increase_salary (
    p_employee_id IN Employees.emp_id%TYPE,
    p_raise_percent IN NUMBER
)
AS
    v_new_salary Employees.salary%TYPE;
BEGIN
    -- 1. Update the salary based on the input parameters
    UPDATE Employees
    SET salary = salary * (1 + p_raise_percent)
    WHERE emp_id = p_employee_id
    RETURNING salary INTO v_new_salary;

    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Salary updated to: ' || v_new_salary);
        COMMIT;
    ELSE
        DBMS_OUTPUT.PUT_LINE('Employee ID ' || p_employee_id || ' not found.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE; -- Re-raise the exception to the calling environment
END increase_salary;
/
```

#### B. Parameter Modes

Procedures use parameters to exchange data with the caller.

| Mode | Description | Used to | Mandatory? |
| :--- | :--- | :--- | :--- |
| **`IN`** | Used to pass values *into* the procedure. The procedure cannot change the value of an `IN` parameter. | Input data | No |
| **`OUT`** | Used to pass values *out* of the procedure back to the caller. The procedure must assign a value before exiting. | Return results | No |
| **`IN OUT`** | Used to pass a value *into* the procedure, which can then be modified and passed *back out* to the caller. | Modify existing data | No |

```sql
-- Example Execution
DECLARE
    v_final_salary Employees.salary%TYPE;
BEGIN
    -- Execute procedure
    increase_salary(p_employee_id => 101, p_raise_percent => 0.05);
END;
/
```

-----

### 2\. Functions

A **Function** is similar to a procedure, but it is specifically designed to **compute and return a single value** to the calling environment. Functions are often used within SQL statements (`SELECT`, `WHERE`, `ORDER BY` clauses) as if they were built-in SQL functions.

#### A. Creating a Function

Functions require a `RETURN datatype` clause in the header and must use the **`RETURN`** statement within the executable body.

```sql
CREATE OR REPLACE FUNCTION get_employee_tax_rate (
    p_employee_id IN Employees.emp_id%TYPE
)
RETURN NUMBER -- Mandatory: specifies the data type of the returned value
IS
    v_salary Employees.salary%TYPE;
    v_tax_rate NUMBER := 0;
BEGIN
    -- Retrieve salary for the calculation
    SELECT salary INTO v_salary FROM Employees WHERE emp_id = p_employee_id;

    -- Calculate tax rate based on salary
    IF v_salary > 100000 THEN
        v_tax_rate := 0.25;
    ELSIF v_salary > 50000 THEN
        v_tax_rate := 0.15;
    ELSE
        v_tax_rate := 0.10;
    END IF;

    RETURN v_tax_rate; -- Mandatory: returns the single result value

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0; -- Must return a value even if an error occurs
END get_employee_tax_rate;
/
```

#### B. Execution Context

Functions can be called directly from SQL queries:

```sql
-- Example Execution (Calling from a SELECT statement)
SELECT
    first_name,
    salary,
    get_employee_tax_rate(emp_id) AS tax_rate
FROM
    Employees
WHERE
    dept_id = 10;
```

-----

### 3\. Packages

A **Package** is a container that logically groups related PL/SQL procedures, functions, variables, and cursors. Packages are composed of two parts: the specification (header) and the body.

#### A. Benefits of Packages

  * **Modularity:** Organizes code logically (e.g., all HR functions in one package).
  * **Security:** Allows procedures to be public while internal helper functions remain private (declared only in the body).
  * **Performance:** Packages are loaded into memory once when first called, improving subsequent execution speed.
  * **Global Variables:** Package variables maintain their value for the duration of the session.

#### B. Package Specification (Header)

Defines the **public interface**â€”what the user can see and execute.

```sql
CREATE OR REPLACE PACKAGE hr_tools AS
    -- Public constant visible outside
    c_min_salary CONSTANT NUMBER := 40000;

    -- Public procedure declaration
    PROCEDURE transfer_employee (
        p_emp_id IN Employees.emp_id%TYPE,
        p_new_dept_id IN Departments.dept_id%TYPE
    );

    -- Public function declaration
    FUNCTION get_annual_bonus (
        p_emp_id IN Employees.emp_id%TYPE
    ) RETURN NUMBER;
END hr_tools;
/
```

#### C. Package Body

Contains the **implementation details** (the actual code) for the declared functions and procedures. It can also hold private, non-declared program units.

```sql
CREATE OR REPLACE PACKAGE BODY hr_tools AS
    -- Implementation of the procedure
    PROCEDURE transfer_employee (
        p_emp_id IN Employees.emp_id%TYPE,
        p_new_dept_id IN Departments.dept_id%TYPE
    )
    AS
    BEGIN
        UPDATE Employees
        SET dept_id = p_new_dept_id
        WHERE emp_id = p_emp_id;

        COMMIT;
    END transfer_employee;

    -- Implementation of the function
    FUNCTION get_annual_bonus (
        p_emp_id IN Employees.emp_id%TYPE
    ) RETURN NUMBER
    AS
        v_salary Employees.salary%TYPE;
    BEGIN
        SELECT salary INTO v_salary FROM Employees WHERE emp_id = p_emp_id;
        RETURN v_salary * 0.10; -- 10% bonus
    END get_annual_bonus;
END hr_tools;
/
```

#### D. Calling Package Units

Program units inside a package are called using dot notation: `package_name.program_unit_name`.

```sql
BEGIN
    -- Call the packaged procedure
    hr_tools.transfer_employee(p_emp_id => 102, p_new_dept_id => 30);

    -- Call the packaged function
    DBMS_OUTPUT.PUT_LINE('Bonus: ' || hr_tools.get_annual_bonus(p_emp_id => 102));
END;
/
```

-----

### 4\. Triggers

A **Trigger** is a named PL/SQL block that is stored in the database and **executes automatically** (implicitly) when a specific DML or DDL event occurs on a table or schema. Triggers are primarily used for enforcing complex business rules, auditing, and maintaining derived data.

#### A. Defining Trigger Components

1.  **Timing:** `BEFORE` or `AFTER` the DML statement.
2.  **Event:** `INSERT`, `UPDATE`, or `DELETE` (or a combination).
3.  **Level:** `FOR EACH ROW` (fires once per affected row) or `FOR EACH STATEMENT` (fires once per statement).

#### B. Creating a Row-Level Trigger

Row-level triggers can access the data being changed using two special correlation identifiers:

  * **`:OLD`**: References the column value **before** the DML operation.
  * **`:NEW`**: References the column value **after** the DML operation.

<!-- end list -->

```sql
CREATE OR REPLACE TRIGGER trg_audit_salary_change
BEFORE UPDATE OF salary ON Employees -- Event: Fired BEFORE update on the salary column
FOR EACH ROW                         -- Level: Fired once for every row updated
WHEN (NEW.salary < OLD.salary)       -- Optional: Condition to check BEFORE firing
BEGIN
    -- Enforce a business rule: Prevent salary decreases
    IF :NEW.salary < :OLD.salary THEN
        -- Raise a user-defined application error (number between -20000 and -20999)
        RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be decreased. Original value: ' || :OLD.salary);
    END IF;

    -- Auditing: Record who made the change and when
    INSERT INTO Salary_Audit (
        emp_id, old_salary, new_salary, change_date, changed_by
    ) VALUES (
        :OLD.emp_id, :OLD.salary, :NEW.salary, SYSDATE, USER
    );
END;
/
```

#### C. Use Cases for Triggers

  * **`BEFORE INSERT`**: Used to standardize data or populate calculated columns (e.g., generating primary keys or setting default dates).
  * **`AFTER UPDATE`**: Used for auditing or logging changes to a history table.
  * **`BEFORE UPDATE` (on a view):** Used to allow DML on views that are otherwise non-updatable (called "INSTEAD OF" triggers).

<!-- end list -->

