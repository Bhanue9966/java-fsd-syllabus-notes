## üìê PL/SQL Cursors

A **Cursor** is a pointer or a handle to a private SQL area in the database memory where the results of a SQL statement are stored. Cursors are necessary in procedural languages like PL/SQL because SQL is designed to handle entire sets of data at once, while PL/SQL often needs to process data **row-by-row**.

-----

### 1\. Implicit vs. Explicit Cursors

PL/SQL manages two types of cursors, depending on the complexity of the operation.

#### A. Implicit Cursors

An implicit cursor is **automatically declared and managed** by the Oracle engine for internal processing whenever:

1.  A standard DML statement (`INSERT`, `UPDATE`, `DELETE`) is executed.
2.  A `SELECT INTO` statement is executed (which must return exactly one row).

You reference the implicit cursor through the reserved name **`SQL%`** and its attributes.

| Attribute | Description | Use Case |
| :--- | :--- | :--- |
| **`SQL%ROWCOUNT`** | Number of rows affected by the DML statement. | Checking how many rows were updated. |
| **`SQL%FOUND`** | `TRUE` if at least one row was affected. | Checking if an `UPDATE` succeeded. |
| **`SQL%NOTFOUND`** | `TRUE` if zero rows were affected. | Checking if an `INSERT` was executed. |

```sql
BEGIN
    UPDATE Employees
    SET salary = salary * 1.10
    WHERE dept_id = 10;

    -- Check if any rows were updated
    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE(SQL%ROWCOUNT || ' employees received a raise.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('No employees in department 10 found.');
    END IF;
END;
/
```

#### B. Explicit Cursors

An explicit cursor must be **manually declared and managed** by the programmer to handle `SELECT` statements that are expected to return **multiple rows**.

-----

### 2\. Explicit Cursor Steps

Processing a multi-row result set using an explicit cursor involves four distinct steps.

#### A. Declaration

The cursor is declared in the **`DECLARE`** section, associating a name with the `SELECT` query.

```sql
DECLARE
    -- 1. Declare the cursor
    CURSOR c_low_salary_emps IS
        SELECT emp_id, first_name, salary
        FROM Employees
        WHERE salary < 50000;

    -- 2. Declare variables to hold the fetched data
    v_emp_id     Employees.emp_id%TYPE;
    v_first_name Employees.first_name%TYPE;
    v_salary     Employees.salary%TYPE;
BEGIN
    -- ...
```

#### B. Opening

The **`OPEN`** command executes the `SELECT` query and loads the result set into the cursor's active set area in memory.

```sql
-- 3. Open the cursor
OPEN c_low_salary_emps;
-- ...
```

#### C. Fetching

The **`FETCH`** command retrieves a single row from the cursor's active set and places the column values into the declared variables (`INTO` clause). This process is typically performed inside a loop.

```sql
    LOOP
        -- 4. Fetch the next row into variables
        FETCH c_low_salary_emps INTO v_emp_id, v_first_name, v_salary;

        -- 5. Exit the loop when no more rows are found
        EXIT WHEN c_low_salary_emps%NOTFOUND;

        -- Process the row data
        DBMS_OUTPUT.PUT_LINE('Processing ' || v_first_name || ' (ID: ' || v_emp_id || ')');
    END LOOP;
-- ...
```

#### D. Closing

The **`CLOSE`** command releases the memory and resources associated with the cursor's active set. This is a critical step to prevent memory leaks.

```sql
-- 6. Close the cursor
CLOSE c_low_salary_emps;
END;
/
```

### 3\. Cursor Attributes (Explicit)

Explicit cursors also have attributes used to control the loop and check the status of the operation.

| Attribute | Description | Use Case |
| :--- | :--- | :--- |
| **`%ISOPEN`** | Returns `TRUE` if the cursor is currently open. | Checking if a cursor needs to be closed. |
| **`%FOUND`** | Returns `TRUE` if the last `FETCH` retrieved a row successfully. | Loop control (check before processing). |
| **`%NOTFOUND`** | Returns `TRUE` if the last `FETCH` failed to retrieve a row. | **Loop control (used in `EXIT WHEN`).** |
| **`%ROWCOUNT`** | Returns the number of rows fetched so far. | Tracking progress. |

-----

### 4\. Cursor `FOR` Loops (Recommended)

The **Cursor `FOR` Loop** is the most common and efficient way to process multi-row queries. It simplifies the explicit cursor process by automatically handling the **`OPEN`**, **`FETCH`** (into an implicitly declared record), **`EXIT`**, and **`CLOSE`** commands.

```sql
-- Example: Simplified processing using a Cursor FOR Loop
BEGIN
    -- The cursor is declared and processed inline
    FOR r_employee_rec IN (
        SELECT emp_id, first_name, salary
        FROM Employees
        WHERE dept_id = 20
        ORDER BY salary DESC
    )
    LOOP
        -- r_employee_rec is an implicitly declared record (%ROWTYPE)
        DBMS_OUTPUT.PUT_LINE(
            r_employee_rec.first_name || ' earns ' || r_employee_rec.salary
        );

        -- No explicit OPEN, FETCH, or CLOSE required.
    END LOOP;
END;
/
```
